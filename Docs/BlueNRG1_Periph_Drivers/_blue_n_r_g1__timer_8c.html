<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-1,2 Peripherals drivers APIs: BlueNRG1_timer.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-1,2 Peripherals drivers APIs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">BlueNRG1_timer.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides a set of function to manage the sleep timer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_blue_n_r_g1__timer_8h_source.html">BlueNRG1_timer.h</a>&quot;</code><br />
</div>
<p><a href="_blue_n_r_g1__timer_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtimer__context__s.html">timer_context_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1f63d063dc08bd8eff4c15e3942793a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga1f63d063dc08bd8eff4c15e3942793a7">TIMER_20MSB_MASK</a>&#160;&#160;&#160;0xFFFFF0</td></tr>
<tr class="separator:ga1f63d063dc08bd8eff4c15e3942793a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga688ae1692c44833bfe88c044e6be2fe8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga688ae1692c44833bfe88c044e6be2fe8">TIME24_DIFF</a>(a,  b)          &#160;&#160;&#160;(((int32_t)((a - b) &lt;&lt; 8)) &gt;&gt; 8)</td></tr>
<tr class="separator:ga688ae1692c44833bfe88c044e6be2fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1010f6bb6df72adfefbcf4290eb9694"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gae1010f6bb6df72adfefbcf4290eb9694">TIME_DIFF</a>(a,  b)          &#160;&#160;&#160;(((int32_t)((a - b) &lt;&lt; (32-<a class="el" href="group___t_i_m_e_r___exported___constants.html#gaf85745c5225a82174705e02da15c4309">TIMER_BITS</a>))) &gt;&gt; (32-<a class="el" href="group___t_i_m_e_r___exported___constants.html#gaf85745c5225a82174705e02da15c4309">TIMER_BITS</a>))</td></tr>
<tr class="separator:gae1010f6bb6df72adfefbcf4290eb9694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb016a73722365d8453eea25a32cdf7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gaccb016a73722365d8453eea25a32cdf7">TIME_ABSDIFF</a>(a,  b)          &#160;&#160;&#160;((a - b) &amp; <a class="el" href="group___t_i_m_e_r___exported___constants.html#ga00ba68f62b52b73c91ed948087a5f3df">TIMER_MAX_VALUE</a>)</td></tr>
<tr class="separator:gaccb016a73722365d8453eea25a32cdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(a,  b)&#160;&#160;&#160;((a) &lt; (b) )? (a) : (b)</td></tr>
<tr class="separator:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gafa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(a,  b)&#160;&#160;&#160;((a) &lt; (b) )? (b) : (a)</td></tr>
<tr class="separator:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125af6df2956a88705c7efdba86cabe5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga125af6df2956a88705c7efdba86cabe5">ATOMIC_SECTION_BEGIN</a>()</td></tr>
<tr class="separator:ga125af6df2956a88705c7efdba86cabe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfff8120ca5315b54cc5ff907c83902d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gacfff8120ca5315b54cc5ff907c83902d">ATOMIC_SECTION_END</a>()&#160;&#160;&#160;__set_PRIMASK(uwPRIMASK_Bit)</td></tr>
<tr class="separator:gacfff8120ca5315b54cc5ff907c83902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a3333fbe5be3a1d099d7e6b7c81efa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gaf7a3333fbe5be3a1d099d7e6b7c81efa">TIMER_SEL_THR</a>&#160;&#160;&#160;20</td></tr>
<tr class="separator:gaf7a3333fbe5be3a1d099d7e6b7c81efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634253e2e42ed873f90fecbe06a2a229"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga634253e2e42ed873f90fecbe06a2a229">TIMER_TX_EVENT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga634253e2e42ed873f90fecbe06a2a229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2645c3746cb1699f40a0e9d7d31d735"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#gad2645c3746cb1699f40a0e9d7d31d735">TIMER_RX_EVENT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gad2645c3746cb1699f40a0e9d7d31d735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a9917ff14fede3258d8e7b866e16c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga85a9917ff14fede3258d8e7b866e16c9">WAKEUP_TIMER_EN</a>&#160;&#160;&#160;(1&lt;&lt;24)</td></tr>
<tr class="separator:ga85a9917ff14fede3258d8e7b866e16c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8964acb693ef3063dc7aac5b37a606cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___macros.html#ga8964acb693ef3063dc7aac5b37a606cb">TIMER1_EN</a>&#160;&#160;&#160;(1&lt;&lt;25)</td></tr>
<tr class="separator:ga8964acb693ef3063dc7aac5b37a606cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga535132efc461718adb8d3d52e7d47563"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtimer__context__s.html">timer_context_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___types_definitions.html#ga535132efc461718adb8d3d52e7d47563">TIMER_ContextType</a></td></tr>
<tr class="separator:ga535132efc461718adb8d3d52e7d47563"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3128db178d3e2c131cd6e24954c7917a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga3128db178d3e2c131cd6e24954c7917a">TIMER_Init</a> (<a class="el" href="struct_t_i_m_e_r___init_type.html">TIMER_InitType</a> *TIMER_InitStruct)</td></tr>
<tr class="memdesc:ga3128db178d3e2c131cd6e24954c7917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the TIMER functionality.  <a href="group___t_i_m_e_r___public___functions.html#ga3128db178d3e2c131cd6e24954c7917a">More...</a><br /></td></tr>
<tr class="separator:ga3128db178d3e2c131cd6e24954c7917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eeba98c495209667ba227aac604702a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga0eeba98c495209667ba227aac604702a">TIMER_Calibrate</a> (void)</td></tr>
<tr class="memdesc:ga0eeba98c495209667ba227aac604702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a low speed clock calibration and store results in the global context. It updates the XTAL startup time and the interpolator configuration. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration.  <a href="group___t_i_m_e_r___public___functions.html#ga0eeba98c495209667ba227aac604702a">More...</a><br /></td></tr>
<tr class="separator:ga0eeba98c495209667ba227aac604702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b629dcf17ba3268f9241e852464af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga25b629dcf17ba3268f9241e852464af2">TIMER_StartCalibration</a> (void)</td></tr>
<tr class="memdesc:ga25b629dcf17ba3268f9241e852464af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the calibration routine.  <a href="group___t_i_m_e_r___public___functions.html#ga25b629dcf17ba3268f9241e852464af2">More...</a><br /></td></tr>
<tr class="separator:ga25b629dcf17ba3268f9241e852464af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga4a4c60a6b58d5991769bf761f08d8921">TIMER_IsCalibrationRunning</a> (void)</td></tr>
<tr class="memdesc:ga4a4c60a6b58d5991769bf761f08d8921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if a calibration is on going. It relies on the value of the interrupt status. Assumption is that no other modules are managing the interrupt status of the calibrator.  <a href="group___t_i_m_e_r___public___functions.html#ga4a4c60a6b58d5991769bf761f08d8921">More...</a><br /></td></tr>
<tr class="separator:ga4a4c60a6b58d5991769bf761f08d8921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga526ecb65c6e3da467c9e2b75b3aa2be0">TIMER_UpdateCalibrationData</a> (void)</td></tr>
<tr class="memdesc:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records the result of the last calibration in the internal context. It updates the XTAL startup time and the interpolator configuration. It updates also the cumulative STU variable, so it should be called peiodically to manage timer wrapping, regardless of actual need of periodic calibration.  <a href="group___t_i_m_e_r___public___functions.html#ga526ecb65c6e3da467c9e2b75b3aa2be0">More...</a><br /></td></tr>
<tr class="separator:ga526ecb65c6e3da467c9e2b75b3aa2be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4903e54c5a624002bebb0936083bd5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga6d4903e54c5a624002bebb0936083bd5">TIMER_GetCurrentSysTime</a> (void)</td></tr>
<tr class="memdesc:ga6d4903e54c5a624002bebb0936083bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current system time in system time unit (STU). This is a counter that grows since the power up of the system and it never wraps.  <a href="group___t_i_m_e_r___public___functions.html#ga6d4903e54c5a624002bebb0936083bd5">More...</a><br /></td></tr>
<tr class="separator:ga6d4903e54c5a624002bebb0936083bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga59559fc0d99df367a45a91adb9bbb8cd">TIMER_ClearRadioTimerValue</a> (void)</td></tr>
<tr class="memdesc:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Wakeup Timer, Timer1 and Timer2 enabling sleep.  <a href="group___t_i_m_e_r___public___functions.html#ga59559fc0d99df367a45a91adb9bbb8cd">More...</a><br /></td></tr>
<tr class="separator:ga59559fc0d99df367a45a91adb9bbb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga2a5d5795a186f997c752faa6e8b521c0">TIMER_GetFutureSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga2a5d5795a186f997c752faa6e8b521c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="group___t_i_m_e_r___public___functions.html#ga2a5d5795a186f997c752faa6e8b521c0">More...</a><br /></td></tr>
<tr class="separator:ga2a5d5795a186f997c752faa6e8b521c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga9605ce8f587241f028de3a4aa8a11a1c">TIMER_GetPastSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the absolute machine time passed as parameter.  <a href="group___t_i_m_e_r___public___functions.html#ga9605ce8f587241f028de3a4aa8a11a1c">More...</a><br /></td></tr>
<tr class="separator:ga9605ce8f587241f028de3a4aa8a11a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c67015d28baecc93e56488116eb91ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga1c67015d28baecc93e56488116eb91ce">TIMER_GetCurrentCalibrationData</a> (<a class="el" href="group___t_i_m_e_r___exported___types.html#ga643e0ac4c675cd7f9da054e79adb7681">TIMER_CalibrationType</a> *data)</td></tr>
<tr class="memdesc:ga1c67015d28baecc93e56488116eb91ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current calibration data.  <a href="group___t_i_m_e_r___public___functions.html#ga1c67015d28baecc93e56488116eb91ce">More...</a><br /></td></tr>
<tr class="separator:ga1c67015d28baecc93e56488116eb91ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga98d9ad2d334495f69f3c9920dd9576c5">TIMER_SetWakeupTime</a> (uint32_t delay, BOOL allow_sleep)</td></tr>
<tr class="memdesc:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the wakeup time to the specified delay. The delay is converted in machine time and only 20 most significant bits are taken into account. The XTAL startup time is not taken into account for the wakeup, i.e. the system does not wait for the XTAL startup time parameter to trigger the interrupt. The delay is translated into machine time unit (MTU) and it is assigned to the wakeup register.  <a href="group___t_i_m_e_r___public___functions.html#ga98d9ad2d334495f69f3c9920dd9576c5">More...</a><br /></td></tr>
<tr class="separator:ga98d9ad2d334495f69f3c9920dd9576c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1675fc9629b47a676fea2fccd6680e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#gade1675fc9629b47a676fea2fccd6680e">TIMER_SetRadioTimerValue</a> (uint32_t timeout, BOOL event_type, BOOL cal_req)</td></tr>
<tr class="memdesc:gade1675fc9629b47a676fea2fccd6680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program either Timer1 or the Wakeup Timer if the device has enough time to settle after exit from sleep or not. If the timeout is enough in the future, a preconfigured radio transaction is going to trigger at the specified timeout. The timeout is translated into machine time unit (MTU) and it is assigned to the wakeup register. If it is sleeping, the CPU wakes up (no IRQ) when the absolute time mathches the 20 MSB of the timeout written in the register. The transmission or reception starts when the timer value matches the value of timeout plus the time the analog part needs to settle. All the 24 bits are considered in this case. An IRQ related to this event can be generated only when the transaction is completed. In order to get a precise timeout, the radio setup delays are taken into account. They differ if the event is a transmission or reception and if the PLL calibration is requested or not.  <a href="group___t_i_m_e_r___public___functions.html#gade1675fc9629b47a676fea2fccd6680e">More...</a><br /></td></tr>
<tr class="separator:gade1675fc9629b47a676fea2fccd6680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb93a6fc923bc6f2194494e1a679f452"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#gafb93a6fc923bc6f2194494e1a679f452">TIMER_GetRadioTimerValue</a> (uint32_t *time)</td></tr>
<tr class="memdesc:gafb93a6fc923bc6f2194494e1a679f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the Radio timers and the last value programmed in the register.  <a href="group___t_i_m_e_r___public___functions.html#gafb93a6fc923bc6f2194494e1a679f452">More...</a><br /></td></tr>
<tr class="separator:gafb93a6fc923bc6f2194494e1a679f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33749f6656c75367e241c38cfc5dd334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga33749f6656c75367e241c38cfc5dd334">TIMER_updatePeriodSlow</a> (void)</td></tr>
<tr class="memdesc:ga33749f6656c75367e241c38cfc5dd334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of period slow variable in RAM.  <a href="group___t_i_m_e_r___public___functions.html#ga33749f6656c75367e241c38cfc5dd334">More...</a><br /></td></tr>
<tr class="separator:ga33749f6656c75367e241c38cfc5dd334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33c90a5678f3e64cfd3ceed18b8ba82c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga33c90a5678f3e64cfd3ceed18b8ba82c">TIMER_updateWkupTimeOffset</a> (void)</td></tr>
<tr class="memdesc:ga33c90a5678f3e64cfd3ceed18b8ba82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of wakeup_time_offset variable in RAM.  <a href="group___t_i_m_e_r___public___functions.html#ga33c90a5678f3e64cfd3ceed18b8ba82c">More...</a><br /></td></tr>
<tr class="separator:ga33c90a5678f3e64cfd3ceed18b8ba82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbaf884cab51892b78823e47e7b36096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#gafbaf884cab51892b78823e47e7b36096">TIMER_GetNextTimerActivity</a> (uint32_t *nextRadioActivity, uint32_t *nextHostActivity)</td></tr>
<tr class="memdesc:gafbaf884cab51892b78823e47e7b36096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next activities scheduled by the Timer Module.  <a href="group___t_i_m_e_r___public___functions.html#gafbaf884cab51892b78823e47e7b36096">More...</a><br /></td></tr>
<tr class="separator:gafbaf884cab51892b78823e47e7b36096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade83e9fda38c4b08b74af157c7834651"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#gade83e9fda38c4b08b74af157c7834651">TIMER_SysTimeToMachineTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:gade83e9fda38c4b08b74af157c7834651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MTU corresponding to the STU passed as parameter.  <a href="group___t_i_m_e_r___public___functions.html#gade83e9fda38c4b08b74af157c7834651">More...</a><br /></td></tr>
<tr class="separator:gade83e9fda38c4b08b74af157c7834651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga624dafba8076c3ceb2800303e75bf9c2">TIMER_MachineTimeToSysTime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga624dafba8076c3ceb2800303e75bf9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the STU corresponding to the MTU passed as parameter.  <a href="group___t_i_m_e_r___public___functions.html#ga624dafba8076c3ceb2800303e75bf9c2">More...</a><br /></td></tr>
<tr class="separator:ga624dafba8076c3ceb2800303e75bf9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2721cdb6797865137926b3d518d60b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga1e2721cdb6797865137926b3d518d60b">TIMER_UsToSystime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1e2721cdb6797865137926b3d518d60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the system time referred to the time in microseconds passed as parameter.  <a href="group___t_i_m_e_r___public___functions.html#ga1e2721cdb6797865137926b3d518d60b">More...</a><br /></td></tr>
<tr class="separator:ga1e2721cdb6797865137926b3d518d60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1606d739c79f37bab156a7dda5e27f69"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga1606d739c79f37bab156a7dda5e27f69">TIMER_UsToMachinetime</a> (uint32_t time)</td></tr>
<tr class="memdesc:ga1606d739c79f37bab156a7dda5e27f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the machine time referred to the time in microseconds passed as parameter.  <a href="group___t_i_m_e_r___public___functions.html#ga1606d739c79f37bab156a7dda5e27f69">More...</a><br /></td></tr>
<tr class="separator:ga1606d739c79f37bab156a7dda5e27f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga93c87f2f82ef629a0b3665248b7505e3">TIMER_GetAnchorPoint</a> (void)</td></tr>
<tr class="memdesc:ga93c87f2f82ef629a0b3665248b7505e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return timer capture register value in STU.  <a href="group___t_i_m_e_r___public___functions.html#ga93c87f2f82ef629a0b3665248b7505e3">More...</a><br /></td></tr>
<tr class="separator:ga93c87f2f82ef629a0b3665248b7505e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88243574d09e3b9d759930296f08d14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga88243574d09e3b9d759930296f08d14c">TIMER_SetRadioCloseTimeout</a> (void)</td></tr>
<tr class="memdesc:ga88243574d09e3b9d759930296f08d14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program the radio timer (a.k.a Timer1) as close as possible.  <a href="group___t_i_m_e_r___public___functions.html#ga88243574d09e3b9d759930296f08d14c">More...</a><br /></td></tr>
<tr class="separator:ga88243574d09e3b9d759930296f08d14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f8c3a86856743e738ddd2a363c1255"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___public___functions.html#ga12f8c3a86856743e738ddd2a363c1255">TIMER_GetActivitySysDelay</a> (uint8_t event_type, uint8_t cal_req)</td></tr>
<tr class="memdesc:ga12f8c3a86856743e738ddd2a363c1255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the radio setup delay in system time.  <a href="group___t_i_m_e_r___public___functions.html#ga12f8c3a86856743e738ddd2a363c1255">More...</a><br /></td></tr>
<tr class="separator:ga12f8c3a86856743e738ddd2a363c1255"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf454441a6ed3ab9274cd6fa0a67c5041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___t_i_m_e_r___private___types_definitions.html#ga535132efc461718adb8d3d52e7d47563">TIMER_ContextType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___t_i_m_e_r___private___variables.html#gaf454441a6ed3ab9274cd6fa0a67c5041">TIMER_Context</a></td></tr>
<tr class="separator:gaf454441a6ed3ab9274cd6fa0a67c5041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides a set of function to manage the sleep timer. </p>
<dl class="section warning"><dt>Warning</dt><dd>This module must not be included in applications based on the BLE stack library. In that case, the API implementation is managed by the library itself. The API calls remain the same. In the future release the BLE stack library will rely on the Timer module library. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>RF Application Team </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jan-2020</dd></dl>
<p>The basic support is provided by a low speed oscillator with a nominal speed of 32.768 kHz. The low speed oscillator provides a counter that increments at a nominal rate of 30.52 us. The counter is 24 bits wide and the low speed oscillator only increments bits 23:4 (most significant 20 bits) The remaining 4 bits are interpolated using the high speed 16 MHz clock. The counter unit are called conventionally machine time unit (MTU). At the end, the counter resolution will be about 1.91 us and it will wrap every 32 sec. It is important to notice that the interpolated bits will only be functional when the system is out of sleep. While in sleep only the 20 most significant bits will tick. The user can setup a timer that will wakeup the system (if asleep) and it will trigger an interrupt when the timer expires. The user timer will not take into account the high speed XTAL wakeup time. The possible options for the low speed oscillator are:</p><ul>
<li>external 32.768 kHz XTAL</li>
<li>internal ring oscillator (RO)</li>
</ul>
<p>The external 32 kHz XTAL meets the assumption made above regarding the nominal speed. The internal RO, due to technology contraints, is very sensitive to temperature and so the frequency absolute value and its stability have a very wide spread compared to external 32 kHz XTAL. Due to this reason, the concept of calibration or compensation is introduced. The calibration process involves measuring the nominal 32 kHz period using the high speed 16 MHz clock, once this operation is performed, the software will compensate all the timing using the most recent calibration value, hardware will also use the calibration value to tune the interpolator for the least significant 4 bits. The calibration is started by hardware at power-on and software in all the other cases. As a rule of thumb, it can be assumed that the internal RO varies between 30kHz and 60 kHz and in general the lower the temperature, the higher the frequency. In order to cope with this variation a concept of system time unit (STU) is introduced. The STU is defined as scaled clock compared to MTU in order to:</p><ul>
<li>handle variation of internal RO</li>
<li>express easily timing dictated by Bluetooth Low Energy protocol.</li>
</ul>
<p>The STU are absolute unit of time and each unit represent 625/256 us, that is about 2.44 us. The MTU, on the other hand, have a nominal value of 1.91 us, and this value can be assumed constant when using external 32 kHz clock, but it will vary (mainly with temperature variation) when using internal RO. As a design choice, use of MTU is reserved as much as possible to the driver, while STU is exposed to user.</p>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT 2020 STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="_blue_n_r_g1__timer_8c_source.html">BlueNRG1_timer.c</a>.</p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2020 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
