<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-BLE Stack Library APIs, events callbacks &amp; application framework: C:/GIT_vobs/BlueNRG1_2_DK_3_2_1/Library/Bluetooth_LE/inc/bluenrg1_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="STcustom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-BLE Stack Library APIs, events callbacks &amp; application framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5ad7f572bbca03234e8e621e192fc099.html">Library</a></li><li class="navelem"><a class="el" href="dir_da27485afde83d01990c6e7fc5e4b1d5.html">Bluetooth_LE</a></li><li class="navelem"><a class="el" href="dir_50b14757235d9de973ab92e774a20e9e.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bluenrg1_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for BlueNRG-1 Bluetooth Low Energy stack APIs. Autogenerated files, do not edit!!  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ble__status_8h_source.html">ble_status.h</a>&quot;</code><br />
</div>
<p><a href="bluenrg1__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_service___u_u_i_d__t__s.html">Service_UUID_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_include___u_u_i_d__t__s.html">Include_UUID_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_char___u_u_i_d__t__s.html">Char_UUID_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_char___desc___uuid__t__s.html">Char_Desc_Uuid_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_u_u_i_d__t__s.html">UUID_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_handle___entry__t__s.html">Handle_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5ad574baee6641a0326ee817f2d278b4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a></td></tr>
<tr class="separator:a5ad574baee6641a0326ee817f2d278b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac381829daea9db7081e9594c3a5322ea"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a></td></tr>
<tr class="separator:ac381829daea9db7081e9594c3a5322ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c91ab8b82c0d7ac0947fad3251cbf45"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a></td></tr>
<tr class="separator:a6c91ab8b82c0d7ac0947fad3251cbf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4bdf54cd7052b0e86de41c615631e9"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_service___u_u_i_d__t__s.html">Service_UUID_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#a4f4bdf54cd7052b0e86de41c615631e9">Service_UUID_t</a></td></tr>
<tr class="separator:a4f4bdf54cd7052b0e86de41c615631e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25f740382f761d50307a033b0d4b77c"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_include___u_u_i_d__t__s.html">Include_UUID_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#ad25f740382f761d50307a033b0d4b77c">Include_UUID_t</a></td></tr>
<tr class="separator:ad25f740382f761d50307a033b0d4b77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada430e6ce6bfdd7d1d12e7b0a954786e"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_char___u_u_i_d__t__s.html">Char_UUID_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#ada430e6ce6bfdd7d1d12e7b0a954786e">Char_UUID_t</a></td></tr>
<tr class="separator:ada430e6ce6bfdd7d1d12e7b0a954786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aed71c621c593ebfe257326e0734eb2"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_char___desc___uuid__t__s.html">Char_Desc_Uuid_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#a9aed71c621c593ebfe257326e0734eb2">Char_Desc_Uuid_t</a></td></tr>
<tr class="separator:a9aed71c621c593ebfe257326e0734eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd9bdce9ac1181c683947604eb96e44"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_u_u_i_d__t__s.html">UUID_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a></td></tr>
<tr class="separator:a2bd9bdce9ac1181c683947604eb96e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e49c7305b7ff1d34fec3f2e4bcf42b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_handle___entry__t__s.html">Handle_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__api_8h.html#a46e49c7305b7ff1d34fec3f2e4bcf42b">Handle_Entry_t</a></td></tr>
<tr class="separator:a46e49c7305b7ff1d34fec3f2e4bcf42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaec954b9149e7996e0d09fc6a5a712e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaaec954b9149e7996e0d09fc6a5a712e7">hci_disconnect</a> (uint16_t Connection_Handle, uint8_t Reason)</td></tr>
<tr class="memdesc:gaaec954b9149e7996e0d09fc6a5a712e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group___h_c_i___a_p_i.html#gaaec954b9149e7996e0d09fc6a5a712e7">hci_disconnect</a> is used to terminate an existing connection. The Connection_Handle command parameter indicates which connection is to be disconnected. The Reason command parameter indicates the reason for ending the connection. The remote Controller will receive the Reason command parameter in the <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event. All synchronous connections on a physical link should be disconnected before the ACL connection on the same physical connection is disconnected. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.1.6) It is important to leave an 100 ms blank window before sending any new command (including system hardware reset), since immediately after <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event, system could save important information in non volatile memory.  <a href="group___h_c_i___a_p_i.html#gaaec954b9149e7996e0d09fc6a5a712e7">More...</a><br /></td></tr>
<tr class="separator:gaaec954b9149e7996e0d09fc6a5a712e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777968e990af76a7880dda023015e287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga777968e990af76a7880dda023015e287">hci_read_remote_version_information</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga777968e990af76a7880dda023015e287"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command will obtain the values for the version information for the remote device identified by the Connection_Handle parameter. The Connection_Handle must be a Connection_Handle for an ACL or LE connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.1.23)  <a href="group___h_c_i___a_p_i.html#ga777968e990af76a7880dda023015e287">More...</a><br /></td></tr>
<tr class="separator:ga777968e990af76a7880dda023015e287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b89a8125281800909d9ff99fcb6e5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga6b89a8125281800909d9ff99fcb6e5e0">hci_set_event_mask</a> (uint8_t Event_Mask[8])</td></tr>
<tr class="memdesc:ga6b89a8125281800909d9ff99fcb6e5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Set_Event_Mask command is used to control which events are generated by the HCI for the Host. If the bit in the Event_Mask is set to a one, then the event associated with that bit will be enabled. For an LE Controller, the LE Meta Event bit in the Event_Mask shall enable or disable all LE events in the LE Meta Event (see Section 7.7.65). The Host has to deal with each event that occurs. The event mask allows the Host to control how much it is interrupted. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.1)  <a href="group___h_c_i___a_p_i.html#ga6b89a8125281800909d9ff99fcb6e5e0">More...</a><br /></td></tr>
<tr class="separator:ga6b89a8125281800909d9ff99fcb6e5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a223572ab7974141b06af81a2bdb87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga70a223572ab7974141b06af81a2bdb87">hci_reset</a> (void)</td></tr>
<tr class="memdesc:ga70a223572ab7974141b06af81a2bdb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Reset command will reset the Link Layer on an LE Controller. The Reset command shall not affect the used HCI transport layer since the HCI transport layers may have reset mechanisms of their own. After the reset is completed, the current operational state will be lost, the Controller will enter standby mode and the Controller will automatically revert to the default values for the parameters for which default values are defined in the specification. Note: The Reset command will not necessarily perform a hardware reset. This is implementation defined. The Host shall not send additional HCI commands before the Command Complete event related to the Reset command has been received. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.2)  <a href="group___h_c_i___a_p_i.html#ga70a223572ab7974141b06af81a2bdb87">More...</a><br /></td></tr>
<tr class="separator:ga70a223572ab7974141b06af81a2bdb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf415dc665ccc3bd6b6b2ae9557830d48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaf415dc665ccc3bd6b6b2ae9557830d48">hci_read_transmit_power_level</a> (uint16_t Connection_Handle, uint8_t Type, int8_t *Transmit_Power_Level)</td></tr>
<tr class="memdesc:gaf415dc665ccc3bd6b6b2ae9557830d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the values for the Transmit_Power_Level parameter for the specified Connection_Handle. The Connection_Handle shall be a Connection_Handle for an ACL connection. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.3.35)  <a href="group___h_c_i___a_p_i.html#gaf415dc665ccc3bd6b6b2ae9557830d48">More...</a><br /></td></tr>
<tr class="separator:gaf415dc665ccc3bd6b6b2ae9557830d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69241ad34714d9ee7114cd7f326bd139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga69241ad34714d9ee7114cd7f326bd139">hci_read_local_version_information</a> (uint8_t *HCI_Version, uint16_t *HCI_Revision, uint8_t *LMP_PAL_Version, uint16_t *Manufacturer_Name, uint16_t *LMP_PAL_Subversion)</td></tr>
<tr class="memdesc:ga69241ad34714d9ee7114cd7f326bd139"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the values for the version information for the local Controller. The HCI Version information defines the version information of the HCI layer. The LMP/PAL Version information defines the version of the LMP or PAL. The Manufacturer_Name information indicates the manufacturer of the local device. The HCI Revision and LMP/PAL Subversion are implementation dependent. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.1)  <a href="group___h_c_i___a_p_i.html#ga69241ad34714d9ee7114cd7f326bd139">More...</a><br /></td></tr>
<tr class="separator:ga69241ad34714d9ee7114cd7f326bd139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ee61943c3a66eabf617b73a2faf93a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga04ee61943c3a66eabf617b73a2faf93a">hci_read_local_supported_commands</a> (uint8_t Supported_Commands[64])</td></tr>
<tr class="memdesc:ga04ee61943c3a66eabf617b73a2faf93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the list of HCI commands supported for the local Controller. This command shall return the Supported_Commands configuration parameter. It is implied that if a command is listed as supported, the feature underlying that command is also supported. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.2)  <a href="group___h_c_i___a_p_i.html#ga04ee61943c3a66eabf617b73a2faf93a">More...</a><br /></td></tr>
<tr class="separator:ga04ee61943c3a66eabf617b73a2faf93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728e6ab414a1750b739b80cd6b0d6969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga728e6ab414a1750b739b80cd6b0d6969">hci_read_local_supported_features</a> (uint8_t LMP_Features[8])</td></tr>
<tr class="memdesc:ga728e6ab414a1750b739b80cd6b0d6969"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests a list of the supported features for the local Controller. This command will return a list of the LMP features. For details see Part C, Link Manager Protocol Specification on page 227. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.3)  <a href="group___h_c_i___a_p_i.html#ga728e6ab414a1750b739b80cd6b0d6969">More...</a><br /></td></tr>
<tr class="separator:ga728e6ab414a1750b739b80cd6b0d6969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4c0e41e5144a687ba989255d00df82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga2d4c0e41e5144a687ba989255d00df82">hci_read_bd_addr</a> (uint8_t BD_ADDR[6])</td></tr>
<tr class="memdesc:ga2d4c0e41e5144a687ba989255d00df82"><td class="mdescLeft">&#160;</td><td class="mdescRight">On an LE Controller, this command shall read the Public Device Address as defined in [Vol 6] Part B, Section 1.3, Device Address. If this Controller does not have a Public Device Address, the value 0x000000000000 shall be returned. On an LE Controller, the public address shall be the same as the BD_ADDR. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.4.6)  <a href="group___h_c_i___a_p_i.html#ga2d4c0e41e5144a687ba989255d00df82">More...</a><br /></td></tr>
<tr class="separator:ga2d4c0e41e5144a687ba989255d00df82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2ba180d5cf53157c4f999eceeb6b796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaa2ba180d5cf53157c4f999eceeb6b796">hci_read_rssi</a> (uint16_t Connection_Handle, int8_t *RSSI)</td></tr>
<tr class="memdesc:gaa2ba180d5cf53157c4f999eceeb6b796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command reads the Received Signal Strength Indication (RSSI) value from a Controller. For an LE transport, a Connection_Handle is used as the Handle command parameter and return parameter. The meaning of the RSSI metric is an absolute receiver signal strength value in dBm to +/- 6 dB accuracy. If the RSSI cannot be read, the RSSI metric shall be set to 127. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.5.4)  <a href="group___h_c_i___a_p_i.html#gaa2ba180d5cf53157c4f999eceeb6b796">More...</a><br /></td></tr>
<tr class="separator:gaa2ba180d5cf53157c4f999eceeb6b796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0533490da57a99b0a7f4c6eacd282ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga0533490da57a99b0a7f4c6eacd282ed3">hci_le_set_event_mask</a> (uint8_t LE_Event_Mask[8])</td></tr>
<tr class="memdesc:ga0533490da57a99b0a7f4c6eacd282ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Event_Mask command is used to control which LE events are generated by the HCI for the Host. If the bit in the LE_Event_Mask is set to a one, then the event associated with that bit will be enabled. The Host has to deal with each event that is generated by an LE Controller. The event mask allows the Host to control which events will interrupt it. For LE events to be generated, the LE Meta-Event bit in the Event_Mask shall also be set. If that bit is not set, then LE events shall not be generated, regardless of how the LE_Event_Mask is set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.1)  <a href="group___h_c_i___a_p_i.html#ga0533490da57a99b0a7f4c6eacd282ed3">More...</a><br /></td></tr>
<tr class="separator:ga0533490da57a99b0a7f4c6eacd282ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f83f723bb317c6e783ec099d37f4c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga0f83f723bb317c6e783ec099d37f4c10">hci_le_read_buffer_size</a> (uint16_t *HC_LE_ACL_Data_Packet_Length, uint8_t *HC_Total_Num_LE_ACL_Data_Packets)</td></tr>
<tr class="memdesc:ga0f83f723bb317c6e783ec099d37f4c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Buffer_Size command is used to read the maximum size of the data portion of HCI LE ACL Data Packets sent from the Host to the Controller. The Host will segment the data transmitted to the Controller according to these values, so that the HCI Data Packets will contain data with up to this size. The LE_Read_Buffer_Size command also returns the total number of HCI LE ACL Data Packets that can be stored in the data buffers of the Controller. The LE_Read_Buffer_Size command must be issued by the Host before it sends any data to an LE Controller (see Section 4.1.1). If the Controller returns a length value of zero, the Host shall use the Read_Buffer_Size command to determine the size of the data buffers Note: Both the Read_Buffer_Size and LE_Read_Buffer_Size commands may return buffer length and number of packets parameter values that are nonzero. The HC_LE_ACL_Data_Packet_Length return parameter shall be used to determine the size of the L2CAP PDU segments contained in ACL Data Packets, which are transferred from the Host to the Controller to be broken up into packets by the Link Layer. Both the Host and the Controller shall support command and event packets, where the data portion (excluding header) contained in the packets is 255 octets in size. The HC_Total_Num_LE_ACL_Data_Packets return parameter contains the total number of HCI ACL Data Packets that can be stored in the data buffers of the Controller. The Host determines how the buffers are to be divided between different Connection Handles. Note: The HC_LE_ACL_Data_Packet_Length return parameter does not include the length of the HCI Data Packet header. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.2)  <a href="group___h_c_i___a_p_i.html#ga0f83f723bb317c6e783ec099d37f4c10">More...</a><br /></td></tr>
<tr class="separator:ga0f83f723bb317c6e783ec099d37f4c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026e8ea5854901b01d07c5f903b8a0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga026e8ea5854901b01d07c5f903b8a0b1">hci_le_read_local_supported_features</a> (uint8_t LE_Features[8])</td></tr>
<tr class="memdesc:ga026e8ea5854901b01d07c5f903b8a0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests the list of the supported LE features for the Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.3)  <a href="group___h_c_i___a_p_i.html#ga026e8ea5854901b01d07c5f903b8a0b1">More...</a><br /></td></tr>
<tr class="separator:ga026e8ea5854901b01d07c5f903b8a0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a2ba5dba449e423e89d85e5243c9b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga46a2ba5dba449e423e89d85e5243c9b0">hci_le_set_random_address</a> (uint8_t Random_Address[6])</td></tr>
<tr class="memdesc:ga46a2ba5dba449e423e89d85e5243c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Random_Address command is used by the Host to set the LE Random Device Address in the Controller (see [Vol 6] Part B, Section 1.3). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.4)  <a href="group___h_c_i___a_p_i.html#ga46a2ba5dba449e423e89d85e5243c9b0">More...</a><br /></td></tr>
<tr class="separator:ga46a2ba5dba449e423e89d85e5243c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efb6498e4b6d8cc17c93dd9b16fdca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga8efb6498e4b6d8cc17c93dd9b16fdca1">hci_le_set_advertising_parameters</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Advertising_Type, uint8_t Own_Address_Type, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Advertising_Channel_Map, uint8_t Advertising_Filter_Policy)</td></tr>
<tr class="memdesc:ga8efb6498e4b6d8cc17c93dd9b16fdca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Advertising_Parameters command is used by the Host to set the advertising parameters. The Advertising_Interval_Min shall be less than or equal to the Advertising_Interval_Max. The Advertising_Interval_Min and Advertising_Interval_Max should not be the same value to enable the Controller to determine the best advertising interval given other activities. For high duty cycle directed advertising, i.e. when Advertising_Type is 0x01 (ADV_DIRECT_IND, high duty cycle), the Advertising_Interval_Min and Advertising_Interval_Max parameters are not used and shall be ignored. The Advertising_Type is used to determine the packet type that is used for advertising when advertising is enabled. Own_Address_Type parameter indicates the type of address being used in the advertising packets. If Own_Address_Type equals 0x02 or 0x03, the Peer_Address parameter contains the peer's Identity Address and the Peer_Address_Type parameter contains the Peer's Identity Type (i.e. 0x00 or 0x01). These parameters are used to locate the corresponding local IRK in the resolving list; this IRK is used to generate the own address used in the advertisement. If directed advertising is performed, i.e. when Advertising_Type is set to 0x01 (ADV_DIRECT_IND, high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty cycle mode), then the Peer_Address_Type and Peer_Address shall be valid. If Own_Address_Type equals 0x02 or 0x03, the Controller generates the peer's Resolvable Private Address using the peer's IRK corresponding to the peer's Identity Address contained in the Peer_Address parameter and peer's Identity Address Type (i.e. 0x00 or 0x01) contained in the Peer_Address_Type parameter. The Advertising_Channel_Map is a bit field that indicates the advertising channels that shall be used when transmitting advertising packets. At least one channel bit shall be set in the Advertising_Channel_Map parameter. The Advertising_Filter_Policy parameter shall be ignored when directed advertising is enabled. The Host shall not issue this command when advertising is enabled in the Controller; if it is the Command Disallowed error code shall be used. If the advertising interval range provided by the Host (Advertising_Interval_Min, Advertising_Interval_Max) is outside the advertising interval range supported by the Controller, then the Controller shall return the Unsupported Feature or Parameter Value (0x11) error code.  <a href="group___h_c_i___a_p_i.html#ga8efb6498e4b6d8cc17c93dd9b16fdca1">More...</a><br /></td></tr>
<tr class="separator:ga8efb6498e4b6d8cc17c93dd9b16fdca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c4e340f947f0d408391bb33346ac97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga92c4e340f947f0d408391bb33346ac97">hci_le_read_advertising_channel_tx_power</a> (int8_t *Transmit_Power_Level)</td></tr>
<tr class="memdesc:ga92c4e340f947f0d408391bb33346ac97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Advertising_Channel_Tx_Power command is used by the Host to read the transmit power level used for LE advertising channel packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.6)  <a href="group___h_c_i___a_p_i.html#ga92c4e340f947f0d408391bb33346ac97">More...</a><br /></td></tr>
<tr class="separator:ga92c4e340f947f0d408391bb33346ac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6548621f59c4a496afcb0a350caf6976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga6548621f59c4a496afcb0a350caf6976">hci_le_set_advertising_data</a> (uint8_t Advertising_Data_Length, uint8_t Advertising_Data[31])</td></tr>
<tr class="memdesc:ga6548621f59c4a496afcb0a350caf6976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Advertising_Data command is used to set the data used in advertising packets that have a data field. Only the significant part of the Advertising_Data is transmitted in the advertising packets, as defined in [Vol 3] Part C, Section 11., (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.7)  <a href="group___h_c_i___a_p_i.html#ga6548621f59c4a496afcb0a350caf6976">More...</a><br /></td></tr>
<tr class="separator:ga6548621f59c4a496afcb0a350caf6976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2baca315a584d34c23224c52466210a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gad2baca315a584d34c23224c52466210a">hci_le_set_scan_response_data</a> (uint8_t Scan_Response_Data_Length, uint8_t Scan_Response_Data[31])</td></tr>
<tr class="memdesc:gad2baca315a584d34c23224c52466210a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to provide data used in Scanning Packets that have a data field. Only the significant part of the Scan_Response_Data is transmitted in the Scanning Packets, as defined in [Vol 3] Part C, Section 11. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.8)  <a href="group___h_c_i___a_p_i.html#gad2baca315a584d34c23224c52466210a">More...</a><br /></td></tr>
<tr class="separator:gad2baca315a584d34c23224c52466210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f760745908b530506dcc9889bccd348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga4f760745908b530506dcc9889bccd348">hci_le_set_advertise_enable</a> (uint8_t Advertising_Enable)</td></tr>
<tr class="memdesc:ga4f760745908b530506dcc9889bccd348"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Advertise_Enable command is used to request the Controller to start or stop advertising. The Controller manages the timing of advertisements as per the advertising parameters given in the LE_Set_Advertising_Parameters command. The Controller shall continue advertising until the Host issues an LE_Set_Advertise_Enable command with Advertising_Enable set to 0x00 (Advertising is disabled) or until a connection is created or until the Advertising is timed out due to high duty cycle Directed Advertising. In these cases, advertising is then disabled. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.9)  <a href="group___h_c_i___a_p_i.html#ga4f760745908b530506dcc9889bccd348">More...</a><br /></td></tr>
<tr class="separator:ga4f760745908b530506dcc9889bccd348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf827cd334e2d37a4a75c73714b99bdab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaf827cd334e2d37a4a75c73714b99bdab">hci_le_set_scan_parameters</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy)</td></tr>
<tr class="memdesc:gaf827cd334e2d37a4a75c73714b99bdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Scan_Parameters command is used to set the scan parameters. The LE_Scan_Type parameter controls the type of scan to perform. The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the Controller should scan (See [Vol 6] Part B, Section 4.5.3). The LE_Scan_Window parameter shall always be set to a value smaller or equal to the value set for the LE_Scan_Interval parameter. If they are set to the same value scanning should be run continuously. The Own_Address_Type parameter determines the address used (Public or Random Device Address) when performing active scan. The Host shall not issue this command when scanning is enabled in the Controller; if it is the Command Disallowed error code shall be used. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.10)  <a href="group___h_c_i___a_p_i.html#gaf827cd334e2d37a4a75c73714b99bdab">More...</a><br /></td></tr>
<tr class="separator:gaf827cd334e2d37a4a75c73714b99bdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c0aeafb85268e79c42c04ce27c5a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaa5c0aeafb85268e79c42c04ce27c5a65">hci_le_set_scan_enable</a> (uint8_t LE_Scan_Enable, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:gaa5c0aeafb85268e79c42c04ce27c5a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Scan_Enable command is used to start scanning. Scanning is used to discover advertising devices nearby. The Filter_Duplicates parameter controls whether the Link Layer shall filter duplicate advertising reports to the Host, or if the Link Layer should generate advertising reports for each packet received. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.11)  <a href="group___h_c_i___a_p_i.html#gaa5c0aeafb85268e79c42c04ce27c5a65">More...</a><br /></td></tr>
<tr class="separator:gaa5c0aeafb85268e79c42c04ce27c5a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78779c84a0d1f711677c135b4dcafe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gab78779c84a0d1f711677c135b4dcafe9">hci_le_create_connection</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Initiator_Filter_Policy, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:gab78779c84a0d1f711677c135b4dcafe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Create_Connection command is used to create a Link Layer connection to a connectable advertiser. The LE_Scan_Interval and LE_Scan_Window parameters are recommendations from the Host on how long (LE_Scan_Window) and how frequently (LE_Scan_Interval) the Controller should scan. The LE_Scan_Window parameter shall be set to a value smaller or equal to the value set for the LE_Scan_Interval parameter. If both are set to the same value, scanning should run continuously. The Initiator_Filter_Policy is used to determine whether the White List is used. If the White List is not used, the Peer_Address_Type and the Peer_Address parameters specify the address type and address of the advertising device to connect to. The Link Layer shall set the address in the CONNECT_REQ packets to either the Public Device Address or the Random Device Addressed based on the Own_Address_Type parameter. The Conn_Interval_Min and Conn_Interval_Max parameters define the minimum and maximum allowed connection interval. The Conn_Interval_Min parameter shall not be greater than the Conn_Interval_Max parameter. The Conn_Latency parameter defines the maximum allowed connection latency (see [Vol 6] Part B, Section 4.5.1). The Supervision_Timeout parameter defines the link supervision timeout for the connection. The Supervision_Timeout in milliseconds shall be larger than (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds. (See [Vol 6] Part B, Section 4.5.2). The Minimum_CE_Length and Maximum_CE_Length parameters are informative parameters providing the Controller with the expected minimum and maximum length of the connection events. The Minimum_CE_Length parameter shall be less than or equal to the Maximum_CE_Length parameter. The Host shall not issue this command when another LE_Create_Connection is pending in the Controller; if this does occur the Controller shall return the Command Disallowed error code shall be used. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.12)  <a href="group___h_c_i___a_p_i.html#gab78779c84a0d1f711677c135b4dcafe9">More...</a><br /></td></tr>
<tr class="separator:gab78779c84a0d1f711677c135b4dcafe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2e81b045a7be0ce2eb41b5b5f7b7c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga2b2e81b045a7be0ce2eb41b5b5f7b7c2">hci_le_create_connection_cancel</a> (void)</td></tr>
<tr class="memdesc:ga2b2e81b045a7be0ce2eb41b5b5f7b7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Create_Connection_Cancel command is used to cancel the LE_Create_Connection command. This command shall only be issued after the LE_Create_Connection command has been issued, a Command Status event has been received for the LE Create Connection command and before the LE Connection Complete event. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.13)  <a href="group___h_c_i___a_p_i.html#ga2b2e81b045a7be0ce2eb41b5b5f7b7c2">More...</a><br /></td></tr>
<tr class="separator:ga2b2e81b045a7be0ce2eb41b5b5f7b7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b286059844d2383e7b4b03a6a886d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga87b286059844d2383e7b4b03a6a886d0">hci_le_read_white_list_size</a> (uint8_t *White_List_Size)</td></tr>
<tr class="memdesc:ga87b286059844d2383e7b4b03a6a886d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_White_List_Size command is used to read the total number of white list entries that can be stored in the Controller. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.14)  <a href="group___h_c_i___a_p_i.html#ga87b286059844d2383e7b4b03a6a886d0">More...</a><br /></td></tr>
<tr class="separator:ga87b286059844d2383e7b4b03a6a886d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb89c4e1db387d70786fd8e95f8f0a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gadb89c4e1db387d70786fd8e95f8f0a2f">hci_le_clear_white_list</a> (void)</td></tr>
<tr class="memdesc:gadb89c4e1db387d70786fd8e95f8f0a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Clear_White_List command is used to clear the white list stored in the Controller. This command can be used at any time except when: - the advertising filter policy uses the white list and advertising is enabled. - the scanning filter policy uses the white list and scanning is enabled. - the initiator filter policy uses the white list and an LE_Create_Connection command is outstanding. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.15)  <a href="group___h_c_i___a_p_i.html#gadb89c4e1db387d70786fd8e95f8f0a2f">More...</a><br /></td></tr>
<tr class="separator:gadb89c4e1db387d70786fd8e95f8f0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab010359d138490774dc0495499e52383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gab010359d138490774dc0495499e52383">hci_le_add_device_to_white_list</a> (uint8_t Address_Type, uint8_t Address[6])</td></tr>
<tr class="memdesc:gab010359d138490774dc0495499e52383"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Add_Device_To_White_List command is used to add a single device to the white list stored in the Controller. This command can be used at any time except when: - the advertising filter policy uses the white list and advertising is enabled. - the scanning filter policy uses the white list and scanning is enabled. - the initiator filter policy uses the white list and a create connection command is outstanding. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.16)  <a href="group___h_c_i___a_p_i.html#gab010359d138490774dc0495499e52383">More...</a><br /></td></tr>
<tr class="separator:gab010359d138490774dc0495499e52383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a0d6443a7de4b6e9780a594eb161c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga91a0d6443a7de4b6e9780a594eb161c8">hci_le_remove_device_from_white_list</a> (uint8_t Address_Type, uint8_t Address[6])</td></tr>
<tr class="memdesc:ga91a0d6443a7de4b6e9780a594eb161c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Remove_Device_From_White_List command is used to remove a single device from the white list stored in the Controller. This command can be used at any time except when: - the advertising filter policy uses the white list and advertising is enabled. - the scanning filter policy uses the white list and scanning is enabled. - the initiator filter policy uses the white list and a create connection command is outstanding. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.17)  <a href="group___h_c_i___a_p_i.html#ga91a0d6443a7de4b6e9780a594eb161c8">More...</a><br /></td></tr>
<tr class="separator:ga91a0d6443a7de4b6e9780a594eb161c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b1c0e2aede814f82bab64c843710eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga0b1c0e2aede814f82bab64c843710eb8">hci_le_connection_update</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ga0b1c0e2aede814f82bab64c843710eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Connection_Update command is used to change the Link Layer connection parameters of a connection. This command is supported only on master side. The Conn_Interval_Min and Conn_Interval_Max parameters are used to define the minimum and maximum allowed connection interval. The Conn_Interval_Min parameter shall not be greater than the Conn_Interval_Max parameter. The Conn_Latency parameter shall define the maximum allowed connection latency. The Supervision_Timeout parameter shall define the link supervision timeout for the LE link. The Supervision_Timeout in milliseconds shall be larger than (1 + Conn_Latency) * Conn_Interval_Max * 2, where Conn_Interval_Max is given in milliseconds. The Minimum_CE_Length and Maximum_CE_Length are information parameters providing the Controller with a hint about the expected minimum and maximum length of the connection events. The Minimum_CE_Length shall be less than or equal to the Maximum_CE_Length. The actual parameter values selected by the Link Layer may be different from the parameter values provided by the Host through this command. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.18)  <a href="group___h_c_i___a_p_i.html#ga0b1c0e2aede814f82bab64c843710eb8">More...</a><br /></td></tr>
<tr class="separator:ga0b1c0e2aede814f82bab64c843710eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142fa5ba5e21623a9a52b7d9bdbda47d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga142fa5ba5e21623a9a52b7d9bdbda47d">hci_le_set_host_channel_classification</a> (uint8_t LE_Channel_Map[5])</td></tr>
<tr class="memdesc:ga142fa5ba5e21623a9a52b7d9bdbda47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Host_Channel_Classification command allows the Host to specify a channel classification for data channels based on its "local
       information". This classification persists until overwritten with a subsequent LE_Set_Host_Channel_Classification command or until the Controller is reset using the Reset command (see [Vol 6] Part B, Section 4.5.8.1). If this command is used, the Host should send it within 10 seconds of knowing that the channel classification has changed. The interval between two successive commands sent shall be at least one second. This command shall only be used when the local device supports the Master role. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.19)  <a href="group___h_c_i___a_p_i.html#ga142fa5ba5e21623a9a52b7d9bdbda47d">More...</a><br /></td></tr>
<tr class="separator:ga142fa5ba5e21623a9a52b7d9bdbda47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf667e21884f888373c93b0eb7025c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gabf667e21884f888373c93b0eb7025c58">hci_le_read_channel_map</a> (uint16_t Connection_Handle, uint8_t LE_Channel_Map[5])</td></tr>
<tr class="memdesc:gabf667e21884f888373c93b0eb7025c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Channel_Map command returns the current Channel_Map for the specified Connection_Handle. The returned value indicates the state of the Channel_Map specified by the last transmitted or received Channel_Map (in a CONNECT_REQ or LL_CHANNEL_MAP_REQ message) for the specified Connection_Handle, regardless of whether the Master has received an acknowledgement. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.20)  <a href="group___h_c_i___a_p_i.html#gabf667e21884f888373c93b0eb7025c58">More...</a><br /></td></tr>
<tr class="separator:gabf667e21884f888373c93b0eb7025c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159dbfb800361c7340b9dca5bb5ae48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga159dbfb800361c7340b9dca5bb5ae48c">hci_le_read_remote_used_features</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga159dbfb800361c7340b9dca5bb5ae48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests a list of the used LE features from the remote device. This command shall return a list of the used LE features. For details see [Vol 6] Part B, Section 4.6. This command may be issued on both the master and slave. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.21)  <a href="group___h_c_i___a_p_i.html#ga159dbfb800361c7340b9dca5bb5ae48c">More...</a><br /></td></tr>
<tr class="separator:ga159dbfb800361c7340b9dca5bb5ae48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37d8821ebd604515ef02ba84daf5edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gad37d8821ebd604515ef02ba84daf5edb">hci_le_encrypt</a> (uint8_t Key[16], uint8_t Plaintext_Data[16], uint8_t Encrypted_Data[16])</td></tr>
<tr class="memdesc:gad37d8821ebd604515ef02ba84daf5edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Encrypt command is used to request the Controller to encrypt the Plaintext_Data in the command using the Key given in the command and returns the Encrypted_Data to the Host. The AES-128 bit block cypher is defined in NIST Publication FIPS-197 (<a href="http://csrc.nist.gov/publications/fips/">http://csrc.nist.gov/publications/fips/</a> fips197/fips-197.pdf). (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.22)  <a href="group___h_c_i___a_p_i.html#gad37d8821ebd604515ef02ba84daf5edb">More...</a><br /></td></tr>
<tr class="separator:gad37d8821ebd604515ef02ba84daf5edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a2c7085cbe758d1f686b6bd94cc56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaf6a2c7085cbe758d1f686b6bd94cc56e">hci_le_rand</a> (uint8_t Random_Number[8])</td></tr>
<tr class="memdesc:gaf6a2c7085cbe758d1f686b6bd94cc56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Rand command is used to request the Controller to generate 8 octets of random data to be sent to the Host. The Random_Number shall be generated according to [Vol 2] Part H, Section 2 if the LE Feature (LL Encryption) is supported. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.23)  <a href="group___h_c_i___a_p_i.html#gaf6a2c7085cbe758d1f686b6bd94cc56e">More...</a><br /></td></tr>
<tr class="separator:gaf6a2c7085cbe758d1f686b6bd94cc56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf863aa4133c1f3ed61003b890208ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gacdf863aa4133c1f3ed61003b890208ae">hci_le_start_encryption</a> (uint16_t Connection_Handle, uint8_t Random_Number[8], uint16_t Encrypted_Diversifier, uint8_t Long_Term_Key[16])</td></tr>
<tr class="memdesc:gacdf863aa4133c1f3ed61003b890208ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Start_Encryption command is used to authenticate the given encryption key associated with the remote device specified by the connection handle, and once authenticated will encrypt the connection. The parameters are as defined in [Vol 3] Part H, Section 2.4.4. If the connection is already encrypted then the Controller shall pause connection encryption before attempting to authenticate the given encryption key, and then re-encrypt the connection. While encryption is paused no user data shall be transmitted. On an authentication failure, the connection shall be automatically disconnected by the Link Layer. If this command succeeds, then the connection shall be encrypted. This command shall only be used when the local device's role is Master. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.24)  <a href="group___h_c_i___a_p_i.html#gacdf863aa4133c1f3ed61003b890208ae">More...</a><br /></td></tr>
<tr class="separator:gacdf863aa4133c1f3ed61003b890208ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa601f722c74c4d0b50050355d75c2750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaa601f722c74c4d0b50050355d75c2750">hci_le_long_term_key_request_reply</a> (uint16_t Connection_Handle, uint8_t Long_Term_Key[16])</td></tr>
<tr class="memdesc:gaa601f722c74c4d0b50050355d75c2750"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Long_Term_Key_Request_Reply command is used to reply to an LE Long Term Key Request event from the Controller, and specifies the Long_Term_Key parameter that shall be used for this Connection_Handle. The Long_Term_Key is used as defined in [Vol 6] Part B, Section 5.1.3. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.25)  <a href="group___h_c_i___a_p_i.html#gaa601f722c74c4d0b50050355d75c2750">More...</a><br /></td></tr>
<tr class="separator:gaa601f722c74c4d0b50050355d75c2750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c71158ff405ff2bd208668b63335a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga8c71158ff405ff2bd208668b63335a8c">hci_le_long_term_key_requested_negative_reply</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga8c71158ff405ff2bd208668b63335a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Long_Term_Key_Request_Negative_Reply command is used to reply to an LE Long Term Key Request event from the Controller if the Host cannot provide a Long Term Key for this Connection_Handle. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.26)  <a href="group___h_c_i___a_p_i.html#ga8c71158ff405ff2bd208668b63335a8c">More...</a><br /></td></tr>
<tr class="separator:ga8c71158ff405ff2bd208668b63335a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04bca74218aa29b4e8ff2338bece63be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga04bca74218aa29b4e8ff2338bece63be">hci_le_read_supported_states</a> (uint8_t LE_States[8])</td></tr>
<tr class="memdesc:ga04bca74218aa29b4e8ff2338bece63be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Supported_States command reads the states and state combinations that the link layer supports. See [Vol 6] Part B, Section 1.1.1. LE_States is an 8-octet bit field. If a bit is set to 1 then this state or state combination is supported by the Controller. Multiple bits in LE_States may be set to 1 to indicate support for multiple state and state combinations. All the Advertising type with the Initiate State combinations shall be set only if the corresponding Advertising types and Master Role combination are set. All the Scanning types and the Initiate State combinations shall be set only if the corresponding Scanning types and Master Role combination are set. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.27)  <a href="group___h_c_i___a_p_i.html#ga04bca74218aa29b4e8ff2338bece63be">More...</a><br /></td></tr>
<tr class="separator:ga04bca74218aa29b4e8ff2338bece63be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89019fa5a3a91421a23dbe59bc4a75c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga89019fa5a3a91421a23dbe59bc4a75c2">hci_le_set_data_length</a> (uint16_t Connection_Handle, uint16_t TxOctets, uint16_t TxTime)</td></tr>
<tr class="memdesc:ga89019fa5a3a91421a23dbe59bc4a75c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Data_Length command allows the Host to suggest maximum transmission packet size and maximum packet transmission time (connMaxTxOctets and connMaxTxTime - see [Vol 6] Part B, Section 4.5.10) to be used for a given connection. The Controller may use smaller or larger values based on local information.  <a href="group___h_c_i___a_p_i.html#ga89019fa5a3a91421a23dbe59bc4a75c2">More...</a><br /></td></tr>
<tr class="separator:ga89019fa5a3a91421a23dbe59bc4a75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9534ac5c4b1cfde3b45becc6a76a0e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga9534ac5c4b1cfde3b45becc6a76a0e22">hci_le_read_suggested_default_data_length</a> (uint16_t *SuggestedMaxTxOctets, uint16_t *SuggestedMaxTxTime)</td></tr>
<tr class="memdesc:ga9534ac5c4b1cfde3b45becc6a76a0e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Suggested_Default_Data_Length command allows the Host to read the Host preferred values for the Controller maximum transmitted number of payload octets and maximum packet transmission time to be used for new connections (connInitialMaxTxOctets and connInitialMaxTxTime - see ([Vol 6] Part B, Section 4.5.10).  <a href="group___h_c_i___a_p_i.html#ga9534ac5c4b1cfde3b45becc6a76a0e22">More...</a><br /></td></tr>
<tr class="separator:ga9534ac5c4b1cfde3b45becc6a76a0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48350a35f87222088e672a39318ab0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga48350a35f87222088e672a39318ab0df">hci_le_write_suggested_default_data_length</a> (uint16_t SuggestedMaxTxOctets, uint16_t SuggestedMaxTxTime)</td></tr>
<tr class="memdesc:ga48350a35f87222088e672a39318ab0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Write_Suggested_Default_Data_Length command allows the Host to specify its preferred values for the Controller maximum transmission number of payload octets and maximum packet transmission time to be used for new connections (connInitialMaxTxOctets and connInitialMaxTxTime - see [Vol 6] Part B, Section 4.5.10). The Controller may use smaller or larger values based on local information.  <a href="group___h_c_i___a_p_i.html#ga48350a35f87222088e672a39318ab0df">More...</a><br /></td></tr>
<tr class="separator:ga48350a35f87222088e672a39318ab0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac60440db8b6953f44a34dd66a0e80c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gac60440db8b6953f44a34dd66a0e80c48">hci_le_read_local_p256_public_key</a> (void)</td></tr>
<tr class="memdesc:gac60440db8b6953f44a34dd66a0e80c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Local_P-256_Public_Key command is used to return the local P-256 public key from the Controller. The Controller shall generate a new P-256 public/private key pair upon receipt of this command. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.36)  <a href="group___h_c_i___a_p_i.html#gac60440db8b6953f44a34dd66a0e80c48">More...</a><br /></td></tr>
<tr class="separator:gac60440db8b6953f44a34dd66a0e80c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4727c50ea1f835b5384d059c0c64237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gad4727c50ea1f835b5384d059c0c64237">hci_le_generate_dhkey</a> (uint8_t Remote_P256_Public_Key[64])</td></tr>
<tr class="memdesc:gad4727c50ea1f835b5384d059c0c64237"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Generate_DHKey command is used to initiate generation of a Diffie- Hellman key in the Controller for use over the LE transport. This command takes the remote P-256 public key as input. The Diffie- Hellman key generation uses the private key generated by LE_Read_Local_P256_Public_Key command. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.37)  <a href="group___h_c_i___a_p_i.html#gad4727c50ea1f835b5384d059c0c64237">More...</a><br /></td></tr>
<tr class="separator:gad4727c50ea1f835b5384d059c0c64237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f453c7d9124aa1f53faa0f7e6dd478e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga8f453c7d9124aa1f53faa0f7e6dd478e">hci_le_add_device_to_resolving_list</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Peer_IRK[16], uint8_t Local_IRK[16])</td></tr>
<tr class="memdesc:ga8f453c7d9124aa1f53faa0f7e6dd478e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Add_Device_To_Resolving_List command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller. This command cannot be used when address translation is enabled in the Controller and: - Advertising is enabled.  <a href="group___h_c_i___a_p_i.html#ga8f453c7d9124aa1f53faa0f7e6dd478e">More...</a><br /></td></tr>
<tr class="separator:ga8f453c7d9124aa1f53faa0f7e6dd478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6d1b2105eb756641b31b3d1f9a7021"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga7a6d1b2105eb756641b31b3d1f9a7021">hci_le_remove_device_from_resolving_list</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6])</td></tr>
<tr class="memdesc:ga7a6d1b2105eb756641b31b3d1f9a7021"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Remove_Device_From_Resolving_List command is used to remove one device from the list of address translations used to resolve Resolvable Private Addresses in the controller. This command cannot be used when address translation is enabled in the Controller and: - Advertising is enabled - Scanning is enabled - Create connection command is outstanding This command can be used at any time when address translation is disabled in the Controller. When a Controller cannot remove a device from the resolving list because it is not found, it shall respond with error code 0x02 (Unknown Connection Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.39)  <a href="group___h_c_i___a_p_i.html#ga7a6d1b2105eb756641b31b3d1f9a7021">More...</a><br /></td></tr>
<tr class="separator:ga7a6d1b2105eb756641b31b3d1f9a7021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c483fe9c3c56736bbc5b4f22969eebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga2c483fe9c3c56736bbc5b4f22969eebc">hci_le_clear_resolving_list</a> (void)</td></tr>
<tr class="memdesc:ga2c483fe9c3c56736bbc5b4f22969eebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Clear_Resolving_List command is used to remove all devices from the list of address translations used to resolve Resolvable Private Addresses in the Controller. This command cannot be used when address translation is enabled in the Controller and: - Advertising is enabled.  <a href="group___h_c_i___a_p_i.html#ga2c483fe9c3c56736bbc5b4f22969eebc">More...</a><br /></td></tr>
<tr class="separator:ga2c483fe9c3c56736bbc5b4f22969eebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d6a5b18bf4ff051df7cc78746a2a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gab6d6a5b18bf4ff051df7cc78746a2a8c">hci_le_read_resolving_list_size</a> (uint8_t *Resolving_List_Size)</td></tr>
<tr class="memdesc:gab6d6a5b18bf4ff051df7cc78746a2a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Resolving_List_Size command is used to read the total number of address translation entries in the resolving list that can be stored in the Controller. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.41)  <a href="group___h_c_i___a_p_i.html#gab6d6a5b18bf4ff051df7cc78746a2a8c">More...</a><br /></td></tr>
<tr class="separator:gab6d6a5b18bf4ff051df7cc78746a2a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6824cea0d99729312d99ffd070c5f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga8d6824cea0d99729312d99ffd070c5f1">hci_le_read_peer_resolvable_address</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Peer_Resolvable_Address[6])</td></tr>
<tr class="memdesc:ga8d6824cea0d99729312d99ffd070c5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Peer_Resolvable_Address command is used to get the current peer Resolvable Private Address being used for the corresponding peer Public and Random (static) Identity Address. The peer's resolvable address being used may change after the command is called. This command can be used at any time. When a Controller cannot find a Resolvable Private Address associated with the Peer Identity Address, it shall respond with error code 0x02 (Unknown Connection Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.42)  <a href="group___h_c_i___a_p_i.html#ga8d6824cea0d99729312d99ffd070c5f1">More...</a><br /></td></tr>
<tr class="separator:ga8d6824cea0d99729312d99ffd070c5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4d7fc34b9d5cb8af642d8d3b768fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga5a4d7fc34b9d5cb8af642d8d3b768fec">hci_le_read_local_resolvable_address</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Local_Resolvable_Address[6])</td></tr>
<tr class="memdesc:ga5a4d7fc34b9d5cb8af642d8d3b768fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Local_Resolvable_Address command is used to get the current local Resolvable Private Address being used for the corresponding peer Identity Address. The local's resolvable address being used may change after the command is called. This command can be used at any time. When a Controller cannot find a Resolvable Private Address associated with the Peer Identity Address, it shall respond with error code 0x02 (Unknown Connection Identifier). (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.43)  <a href="group___h_c_i___a_p_i.html#ga5a4d7fc34b9d5cb8af642d8d3b768fec">More...</a><br /></td></tr>
<tr class="separator:ga5a4d7fc34b9d5cb8af642d8d3b768fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3317c7e672c83edee3e1186df0185ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gaf3317c7e672c83edee3e1186df0185ab">hci_le_set_address_resolution_enable</a> (uint8_t Address_Resolution_Enable)</td></tr>
<tr class="memdesc:gaf3317c7e672c83edee3e1186df0185ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Address_Resolution_Enable command is used to enable resolution of Resolvable Private Addresses in the Controller. This causes the Controller to use the resolving list whenever the Controller receives a local or peer Resolvable Private Address. This command can be used at any time except when: - Advertising is enabled.  <a href="group___h_c_i___a_p_i.html#gaf3317c7e672c83edee3e1186df0185ab">More...</a><br /></td></tr>
<tr class="separator:gaf3317c7e672c83edee3e1186df0185ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24370c220c68f04f9ed4670948042f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga24370c220c68f04f9ed4670948042f47">hci_le_set_resolvable_private_address_timeout</a> (uint16_t RPA_Timeout)</td></tr>
<tr class="memdesc:ga24370c220c68f04f9ed4670948042f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Set_Resolvable_Private_Address_Timeout command set the length of time the controller uses a Resolvable Private Address before a new resolvable private address is generated and starts being used. This timeout applies to all addresses generated by the controller. (See Bluetooth Specification v.4.2, Vol. 2, Part E, 7.8.45)  <a href="group___h_c_i___a_p_i.html#ga24370c220c68f04f9ed4670948042f47">More...</a><br /></td></tr>
<tr class="separator:ga24370c220c68f04f9ed4670948042f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53307a9e85ecdcca28aad3401236512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#gae53307a9e85ecdcca28aad3401236512">hci_le_read_maximum_data_length</a> (uint16_t *supportedMaxTxOctets, uint16_t *supportedMaxTxTime, uint16_t *supportedMaxRxOctets, uint16_t *supportedMaxRxTime)</td></tr>
<tr class="memdesc:gae53307a9e85ecdcca28aad3401236512"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LE_Read_Maximum_Data_Length command allows the Host to read the Controller maximum supported payload octets and packet duration times for transmission and reception (supportedMaxTxOctets and supportedMaxTxTime, supportedMaxRxOctets, and supportedMaxRxTime, see [Vol 6] Part B, Section 4.5.10).  <a href="group___h_c_i___a_p_i.html#gae53307a9e85ecdcca28aad3401236512">More...</a><br /></td></tr>
<tr class="separator:gae53307a9e85ecdcca28aad3401236512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9205d36954e747e0cbec275ead4ac424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga9205d36954e747e0cbec275ead4ac424">hci_le_set_privacy_mode</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6], uint8_t Privacy_Mode)</td></tr>
<tr class="memdesc:ga9205d36954e747e0cbec275ead4ac424"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HCI_LE_Set_Privacy_Mode command is used to allow the Host to specify the privacy mode to be used for a given entry on the resolving list. The effect of this setting is specified in [Vol 6] Part B, Section 4.7. When an entry on the resolving list is removed, the mode associated with that entry shall also be removed. This command cannot be used when address translation is enabled in the Controller and: Advertising is enabled Scanning is enabled Create connection command is outstanding This command can be used at any time when address translation is disabled in the Controller. If the device is not on the resolving list, the Controller shall return the error code Unknown Connection Identifier (0x02).  <a href="group___h_c_i___a_p_i.html#ga9205d36954e747e0cbec275ead4ac424">More...</a><br /></td></tr>
<tr class="separator:ga9205d36954e747e0cbec275ead4ac424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2678c233b7fa0a077cb14b943b7bb4da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___a_p_i.html#ga2678c233b7fa0a077cb14b943b7bb4da">hci_tx_acl_data</a> (uint16_t Connection_Handle, uint8_t PB_Flag, uint8_t BC_Flag, uint16_t Data_Length, uint8_t *PDU_Data)</td></tr>
<tr class="memdesc:ga2678c233b7fa0a077cb14b943b7bb4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">API used to send HCI ACL Data Packets to exchange data between the Host and Controller.  <a href="group___h_c_i___a_p_i.html#ga2678c233b7fa0a077cb14b943b7bb4da">More...</a><br /></td></tr>
<tr class="separator:ga2678c233b7fa0a077cb14b943b7bb4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef44bd31c986a61336642b7ed9850b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___t_e_s_t_i_n_g___a_p_i.html#gaaef44bd31c986a61336642b7ed9850b8">hci_le_receiver_test</a> (uint8_t RX_Frequency)</td></tr>
<tr class="memdesc:gaaef44bd31c986a61336642b7ed9850b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT receives test reference packets at a fixed interval. The tester generates the test reference packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.28)  <a href="group___h_c_i___t_e_s_t_i_n_g___a_p_i.html#gaaef44bd31c986a61336642b7ed9850b8">More...</a><br /></td></tr>
<tr class="separator:gaaef44bd31c986a61336642b7ed9850b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0dac0026aad398b4c508e1b7a0f5a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___t_e_s_t_i_n_g___a_p_i.html#gaef0dac0026aad398b4c508e1b7a0f5a2">hci_le_transmitter_test</a> (uint8_t TX_Frequency, uint8_t Length_Of_Test_Data, uint8_t Packet_Payload)</td></tr>
<tr class="memdesc:gaef0dac0026aad398b4c508e1b7a0f5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to start a test where the DUT generates test reference packets at a fixed interval. The Controller shall transmit at maximum power. An LE Controller supporting the LE_Transmitter_Test command shall support Packet_Payload values 0x00, 0x01 and 0x02. An LE Controller may support other values of Packet_Payload. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.29)  <a href="group___h_c_i___t_e_s_t_i_n_g___a_p_i.html#gaef0dac0026aad398b4c508e1b7a0f5a2">More...</a><br /></td></tr>
<tr class="separator:gaef0dac0026aad398b4c508e1b7a0f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0091c01b705edc41999aac607769b76e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_c_i___t_e_s_t_i_n_g___a_p_i.html#ga0091c01b705edc41999aac607769b76e">hci_le_test_end</a> (uint16_t *Number_Of_Packets)</td></tr>
<tr class="memdesc:ga0091c01b705edc41999aac607769b76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to stop any test which is in progress. The Number_Of_Packets for a transmitter test shall be reported as 0x0000. The Number_Of_Packets is an unsigned number and contains the number of received packets. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.8.30)  <a href="group___h_c_i___t_e_s_t_i_n_g___a_p_i.html#ga0091c01b705edc41999aac607769b76e">More...</a><br /></td></tr>
<tr class="separator:ga0091c01b705edc41999aac607769b76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3b1087da93be369db1b1297ee2cb97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#ga7b3b1087da93be369db1b1297ee2cb97">aci_hal_get_fw_build_number</a> (uint16_t *Build_Number)</td></tr>
<tr class="memdesc:ga7b3b1087da93be369db1b1297ee2cb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns the build number associated with the firmware version currently running.  <a href="group___h_a_l___a_p_i.html#ga7b3b1087da93be369db1b1297ee2cb97">More...</a><br /></td></tr>
<tr class="separator:ga7b3b1087da93be369db1b1297ee2cb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa694cc1ba16fb65a85c50acfb0f9d028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#gaa694cc1ba16fb65a85c50acfb0f9d028">aci_hal_write_config_data</a> (uint8_t Offset, uint8_t Length, uint8_t Value[])</td></tr>
<tr class="memdesc:gaa694cc1ba16fb65a85c50acfb0f9d028"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command writes a value to a low level configure data structure. It is useful to setup directly some low level parameters for the system in the runtime.NOTE: This command shall not be called if a command different than Stack Init, HCI_RESET, ACI_HAL_WRITE_CONFIG_DATA or ACI_HAL_READ_CONFIG_DATA has already been called.  <a href="group___h_a_l___a_p_i.html#gaa694cc1ba16fb65a85c50acfb0f9d028">More...</a><br /></td></tr>
<tr class="separator:gaa694cc1ba16fb65a85c50acfb0f9d028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga525ce45a611421ae48dd43c8e32f0b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#ga525ce45a611421ae48dd43c8e32f0b67">aci_hal_read_config_data</a> (uint8_t Offset, uint8_t *Data_Length, uint8_t Data[])</td></tr>
<tr class="memdesc:ga525ce45a611421ae48dd43c8e32f0b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command requests the value in the low level configure data structure. The number of read bytes changes for different Offset.  <a href="group___h_a_l___a_p_i.html#ga525ce45a611421ae48dd43c8e32f0b67">More...</a><br /></td></tr>
<tr class="separator:ga525ce45a611421ae48dd43c8e32f0b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8ce6409d339fcfdad69607cf4f25d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#ga4d8ce6409d339fcfdad69607cf4f25d8">aci_hal_set_tx_power_level</a> (uint8_t En_High_Power, uint8_t PA_Level)</td></tr>
<tr class="memdesc:ga4d8ce6409d339fcfdad69607cf4f25d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the TX power level of the device. By controlling the EN_HIGH_POWER and the PA_LEVEL, the combination of the 2 determines the output power level (dBm). When the system starts up or reboots, the default TX power level will be used, which is the maximum value of 8 dBm. Once this command is given, the output power will be changed instantly, regardless if there is Bluetooth communication going on or not. For example, for debugging purpose, the device can be set to advertise all the time. And use this command to observe the signal strength changing. The system will keep the last received TX power level from the command, i.e. the 2nd command overwrites the previous TX power level. The new TX power level remains until another Set TX Power command, or the system reboots.  <a href="group___h_a_l___a_p_i.html#ga4d8ce6409d339fcfdad69607cf4f25d8">More...</a><br /></td></tr>
<tr class="separator:ga4d8ce6409d339fcfdad69607cf4f25d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e145d90c77f62a854d65321d99dfb5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#ga9e145d90c77f62a854d65321d99dfb5a">aci_hal_le_tx_test_packet_number</a> (uint32_t *Number_Of_Packets)</td></tr>
<tr class="memdesc:ga9e145d90c77f62a854d65321d99dfb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns the number of packets sent in Direct Test Mode. When the Direct TX test is started, a 32-bit counter is used to count how many packets have been transmitted. This command can be used to check how many packets have been sent during the Direct TX test. The counter starts from 0 and counts upwards. The counter can wrap and start from 0 again. The counter is not cleared until the next Direct TX test starts.  <a href="group___h_a_l___a_p_i.html#ga9e145d90c77f62a854d65321d99dfb5a">More...</a><br /></td></tr>
<tr class="separator:ga9e145d90c77f62a854d65321d99dfb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace555eb4b9f225d874f946aa920de1f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#gace555eb4b9f225d874f946aa920de1f5">aci_hal_tone_start</a> (uint8_t RF_Channel, uint8_t Offset)</td></tr>
<tr class="memdesc:gace555eb4b9f225d874f946aa920de1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command starts a carrier frequency, i.e. a tone, on a specific channel. The frequency sine wave at the specific channel may be used for debugging purpose only. The channel ID is a parameter from 0x00 to 0x27 for the 40 BLE channels, e.g. 0x00 for 2.402 GHz, 0x01 for 2.404 GHz etc. This command should not be used when normal Bluetooth activities are ongoing. The tone should be stopped by <a class="el" href="group___h_a_l___a_p_i.html#ga77e0497ce0ec8bbb0d9e5495ff6c7027">aci_hal_tone_stop</a> command.  <a href="group___h_a_l___a_p_i.html#gace555eb4b9f225d874f946aa920de1f5">More...</a><br /></td></tr>
<tr class="separator:gace555eb4b9f225d874f946aa920de1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e0497ce0ec8bbb0d9e5495ff6c7027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#ga77e0497ce0ec8bbb0d9e5495ff6c7027">aci_hal_tone_stop</a> (void)</td></tr>
<tr class="memdesc:ga77e0497ce0ec8bbb0d9e5495ff6c7027"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to stop the previously started <a class="el" href="group___h_a_l___a_p_i.html#gace555eb4b9f225d874f946aa920de1f5">aci_hal_tone_start</a> command.  <a href="group___h_a_l___a_p_i.html#ga77e0497ce0ec8bbb0d9e5495ff6c7027">More...</a><br /></td></tr>
<tr class="separator:ga77e0497ce0ec8bbb0d9e5495ff6c7027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4de85fc7cc00c181c3b01e9ee72154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#gade4de85fc7cc00c181c3b01e9ee72154">aci_hal_get_link_status</a> (uint8_t Link_Status[8], uint16_t Link_Connection_Handle[16/2])</td></tr>
<tr class="memdesc:gade4de85fc7cc00c181c3b01e9ee72154"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns the status of the 8 Bluetooth low energy links managed by the device.  <a href="group___h_a_l___a_p_i.html#gade4de85fc7cc00c181c3b01e9ee72154">More...</a><br /></td></tr>
<tr class="separator:gade4de85fc7cc00c181c3b01e9ee72154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga120ca17ceac401485f6281f2037126b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#ga120ca17ceac401485f6281f2037126b0">aci_hal_set_radio_activity_mask</a> (uint16_t Radio_Activity_Mask)</td></tr>
<tr class="memdesc:ga120ca17ceac401485f6281f2037126b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command set the bitmask associated to <a class="el" href="group___a_c_i___h_a_l__events.html#ga5be9dbe2c8fc3758a12ee9c5e8a95d86">aci_hal_end_of_radio_activity_event</a>. Only the radio activities enabled in the mask will be reported to application by <a class="el" href="group___a_c_i___h_a_l__events.html#ga5be9dbe2c8fc3758a12ee9c5e8a95d86">aci_hal_end_of_radio_activity_event</a>.  <a href="group___h_a_l___a_p_i.html#ga120ca17ceac401485f6281f2037126b0">More...</a><br /></td></tr>
<tr class="separator:ga120ca17ceac401485f6281f2037126b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed24fc99bccbc81d2171ccc30d5f0e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#gaed24fc99bccbc81d2171ccc30d5f0e3f">aci_hal_get_anchor_period</a> (uint32_t *Anchor_Period, uint32_t *Max_Free_Slot)</td></tr>
<tr class="memdesc:gaed24fc99bccbc81d2171ccc30d5f0e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command returns information about the Anchor Period to help application in selecting slot timings when operating in multi-link scenarios.  <a href="group___h_a_l___a_p_i.html#gaed24fc99bccbc81d2171ccc30d5f0e3f">More...</a><br /></td></tr>
<tr class="separator:gaed24fc99bccbc81d2171ccc30d5f0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b21a27d40d972697c5b63a0f54f8829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_a_l___a_p_i.html#ga4b21a27d40d972697c5b63a0f54f8829">aci_hal_set_event_mask</a> (uint32_t Event_Mask)</td></tr>
<tr class="separator:ga4b21a27d40d972697c5b63a0f54f8829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04d32f0009ee0df4fbe4643c4e593a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gaa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> (void)</td></tr>
<tr class="memdesc:gaa04d32f0009ee0df4fbe4643c4e593a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in non-discoverable mode. This command disables the LL advertising.  <a href="group___g_a_p___a_p_i.html#gaa04d32f0009ee0df4fbe4643c4e593a5">More...</a><br /></td></tr>
<tr class="separator:gaa04d32f0009ee0df4fbe4643c4e593a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1472bbcc86d4f3b87615733a0c22bdd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga1472bbcc86d4f3b87615733a0c22bdd9">aci_gap_set_limited_discoverable</a> (uint8_t Advertising_Type, uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Advertising_Filter_Policy, uint8_t Local_Name_Length, uint8_t Local_Name[], uint8_t Service_Uuid_length, uint8_t Service_Uuid_List[], uint16_t Slave_Conn_Interval_Min, uint16_t Slave_Conn_Interval_Max)</td></tr>
<tr class="memdesc:ga1472bbcc86d4f3b87615733a0c22bdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in limited discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.3). The device will be discoverable for maximum period of TGAP (lim_adv_timeout) = 180 seconds (from errata). The advertising can be disabled at any time by issuing <a class="el" href="group___g_a_p___a_p_i.html#gaa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP will use default values for adv intervals for limited discoverable mode (250 ms and 500 ms respectively). To allow a fast connection, the host can set Local_Name, Service_Uuid_List, Slave_Conn_Interval_Min and Slave_Conn_Interval_Max. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be set in advertised data using GAP_Update_Adv_Data command separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - Power Level When advertising timeout happens (i.e. limited discovery period has elapsed), controller generates <a class="el" href="group___a_c_i___g_a_p__events.html#ga2b2959f4046febc21171af4788a40da0">aci_gap_limited_discoverable_event</a> event.  <a href="group___g_a_p___a_p_i.html#ga1472bbcc86d4f3b87615733a0c22bdd9">More...</a><br /></td></tr>
<tr class="separator:ga1472bbcc86d4f3b87615733a0c22bdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1795e7e98ac1e1165238b143a06dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga6b1795e7e98ac1e1165238b143a06dd3">aci_gap_set_discoverable</a> (uint8_t Advertising_Type, uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Advertising_Filter_Policy, uint8_t Local_Name_Length, uint8_t Local_Name[], uint8_t Service_Uuid_length, uint8_t Service_Uuid_List[], uint16_t Slave_Conn_Interval_Min, uint16_t Slave_Conn_Interval_Max)</td></tr>
<tr class="memdesc:ga6b1795e7e98ac1e1165238b143a06dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in general discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.4). The device will be discoverable until the host issues the <a class="el" href="group___g_a_p___a_p_i.html#gaa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP uses the default values for adv intervals for general discoverable mode. When using connectable undirected advertising events: - Adv_Interval_Min = 30 ms - Adv_Interval_Max = 60 ms When using non- connectable advertising events or scannable undirected advertising events: - Adv_Interval_Min = 100 ms - Adv_Interval_Max = 150 ms Host can set the Local Name, a Service UUID list and the Slave Connection Interval Range. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be also set using <a class="el" href="group___g_a_p___a_p_i.html#gaff0e0210b67c4fed57edc3e228365a8c" title="This command can be used to update the advertising data for a particular AD type. If the AD type spec...">aci_gap_update_adv_data()</a> separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - TX Power Level.  <a href="group___g_a_p___a_p_i.html#ga6b1795e7e98ac1e1165238b143a06dd3">More...</a><br /></td></tr>
<tr class="separator:ga6b1795e7e98ac1e1165238b143a06dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e333853ba4eb3b6e94f2acdf7597cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga8e333853ba4eb3b6e94f2acdf7597cce">aci_gap_set_direct_connectable</a> (uint8_t Own_Address_Type, uint8_t Directed_Advertising_Type, uint8_t Direct_Address_Type, uint8_t Direct_Address[6], uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max)</td></tr>
<tr class="memdesc:ga8e333853ba4eb3b6e94f2acdf7597cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device in direct connectable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.3.3). Device uses direct connectable mode to advertise using High Duty cycle advertisement events or Low Duty cycle advertisement events and the address as either what is specified in the Own Address Type parameter. The command specifies the type of the advertising used. If the privacy is enabled, the Type parameter in reconnection address is used for advertising, otherwise the address of the type specified in OwnAddrType is used. The device will be in directed connectable mode only for 1.28 seconds. If no connection is established within this duration, the device enters non discoverable mode and advertising will have to be again enabled explicitly. The controller generates a <a class="el" href="group___h_c_i___l_e__meta__events.html#gaca8160d0515ff237c4c8f4db8e45c77a">hci_le_connection_complete_event</a> event with the status set to 0x3C (Directed Advertising Timeout) if the connection was not established and 0x00 if the connection was successfully established. If Host privacy (i.e. privacy 1.1) is enabled this command returns BLE_STATUS_INVALID_PARAMS.  <a href="group___g_a_p___a_p_i.html#ga8e333853ba4eb3b6e94f2acdf7597cce">More...</a><br /></td></tr>
<tr class="separator:ga8e333853ba4eb3b6e94f2acdf7597cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e39b68644bdc0149ea9270427715cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gaf7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> (uint8_t IO_Capability)</td></tr>
<tr class="memdesc:gaf7e39b68644bdc0149ea9270427715cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IO capabilities of the device. This command has to be given only when the device is not in a connected state.  <a href="group___g_a_p___a_p_i.html#gaf7e39b68644bdc0149ea9270427715cd">More...</a><br /></td></tr>
<tr class="separator:gaf7e39b68644bdc0149ea9270427715cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2bee68b2757f1aa0a2034a90b8d2f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gad2bee68b2757f1aa0a2034a90b8d2f61">aci_gap_set_authentication_requirement</a> (uint8_t Bonding_Mode, uint8_t MITM_Mode, uint8_t SC_Support, uint8_t KeyPress_Notification_Support, uint8_t Min_Encryption_Key_Size, uint8_t Max_Encryption_Key_Size, uint8_t Use_Fixed_Pin, uint32_t Fixed_Pin, uint8_t Identity_Address_Type)</td></tr>
<tr class="memdesc:gad2bee68b2757f1aa0a2034a90b8d2f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authentication requirements for the device. This command has to be given only when the device is not in a connected state.  <a href="group___g_a_p___a_p_i.html#gad2bee68b2757f1aa0a2034a90b8d2f61">More...</a><br /></td></tr>
<tr class="separator:gad2bee68b2757f1aa0a2034a90b8d2f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafb71362ebef8fec2dc0c10a05c92e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gacafb71362ebef8fec2dc0c10a05c92e0">aci_gap_set_authorization_requirement</a> (uint16_t Connection_Handle, uint8_t Authorization_Enable)</td></tr>
<tr class="memdesc:gacafb71362ebef8fec2dc0c10a05c92e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authorization requirements of the device. This command has to be given when connected to a device if authorization is required to access services which require authorization.  <a href="group___g_a_p___a_p_i.html#gacafb71362ebef8fec2dc0c10a05c92e0">More...</a><br /></td></tr>
<tr class="separator:gacafb71362ebef8fec2dc0c10a05c92e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5acbb617b13a0880a76d8f063153e6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gab5acbb617b13a0880a76d8f063153e6f">aci_gap_pass_key_resp</a> (uint16_t Connection_Handle, uint32_t Pass_Key)</td></tr>
<tr class="memdesc:gab5acbb617b13a0880a76d8f063153e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command should be send by the host in response to <a class="el" href="group___a_c_i___g_a_p__events.html#ga4820d33fd0fa8fec40c725b78b02c913">aci_gap_pass_key_req_event</a> event. The command parameter contains the pass key which will be used during the pairing process.  <a href="group___g_a_p___a_p_i.html#gab5acbb617b13a0880a76d8f063153e6f">More...</a><br /></td></tr>
<tr class="separator:gab5acbb617b13a0880a76d8f063153e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f00c7d04afae40779a36b27684f840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga14f00c7d04afae40779a36b27684f840">aci_gap_authorization_resp</a> (uint16_t Connection_Handle, uint8_t Authorize)</td></tr>
<tr class="memdesc:ga14f00c7d04afae40779a36b27684f840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authorize a device to access attributes. This command should be send by the host in response to <a class="el" href="group___a_c_i___g_a_p__events.html#ga6d4fcbf921e882f089829f5ed7c63123">aci_gap_authorization_req_event</a> event.  <a href="group___g_a_p___a_p_i.html#ga14f00c7d04afae40779a36b27684f840">More...</a><br /></td></tr>
<tr class="separator:ga14f00c7d04afae40779a36b27684f840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8135485b2fce4116c825e226b43046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gafc8135485b2fce4116c825e226b43046">aci_gap_init</a> (uint8_t Role, uint8_t privacy_enabled, uint8_t device_name_char_len, uint16_t *Service_Handle, uint16_t *Dev_Name_Char_Handle, uint16_t *Appearance_Char_Handle)</td></tr>
<tr class="memdesc:gafc8135485b2fce4116c825e226b43046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristics will also be added: - Device Name - Appearance - Peripheral Preferred Connection Parameters (peripheral role only) WARNING: A section of the Flash memory (pointed by stored_device_id_data_p) is used by this procedure. When this section is empty, data are written inside. This normally happens once during the lifetime of the device, when the command is executed for the first time (or every time it is called after that section has been erased). Do not power off the device while this function is writing into Flash memory. If the functions returns FLASH_WRITE_FAILED, it means that the flash area pointed by stored_device_id_data_p is corrupted (probably due to a power loss during the first call to <a class="el" href="group___g_a_p___a_p_i.html#gafc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a>). To fix the problem, that flash area has to be erased, so that the <a class="el" href="group___g_a_p___a_p_i.html#gafc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a> can reinitialize it correctly.  <a href="group___g_a_p___a_p_i.html#gafc8135485b2fce4116c825e226b43046">More...</a><br /></td></tr>
<tr class="separator:gafc8135485b2fce4116c825e226b43046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7581dbd49beb7d43c2c28a21bd352e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gaf7581dbd49beb7d43c2c28a21bd352e6">aci_gap_set_non_connectable</a> (uint8_t Advertising_Event_Type, uint8_t Own_Address_Type)</td></tr>
<tr class="memdesc:gaf7581dbd49beb7d43c2c28a21bd352e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device into non connectable mode. This mode does not support connection. The privacy setting done in the <a class="el" href="group___g_a_p___a_p_i.html#gafc8135485b2fce4116c825e226b43046">aci_gap_init</a> command plays a role in deciding the valid parameters for this command. Advertiser filter policy is internally set to 0x00.  <a href="group___g_a_p___a_p_i.html#gaf7581dbd49beb7d43c2c28a21bd352e6">More...</a><br /></td></tr>
<tr class="separator:gaf7581dbd49beb7d43c2c28a21bd352e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2212b78100bc3c64553036247fa612bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga2212b78100bc3c64553036247fa612bb">aci_gap_set_undirected_connectable</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Adv_Filter_Policy)</td></tr>
<tr class="memdesc:ga2212b78100bc3c64553036247fa612bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device into undirected connectable mode. If privacy is enabled in the device, a resolvable private address is generated and used as the advertiser's address. If not, the address of the type specified in own_addr_type is used for advertising.  <a href="group___g_a_p___a_p_i.html#ga2212b78100bc3c64553036247fa612bb">More...</a><br /></td></tr>
<tr class="separator:ga2212b78100bc3c64553036247fa612bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga80162feee4f10fbfce5099ba0a7a61ba">aci_gap_slave_security_req</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a slave security request to the master. This command has to be issued to notify the master of the security requirements of the slave. The master may encrypt the link, initiate the pairing procedure, or reject the request.  <a href="group___g_a_p___a_p_i.html#ga80162feee4f10fbfce5099ba0a7a61ba">More...</a><br /></td></tr>
<tr class="separator:ga80162feee4f10fbfce5099ba0a7a61ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0e0210b67c4fed57edc3e228365a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gaff0e0210b67c4fed57edc3e228365a8c">aci_gap_update_adv_data</a> (uint8_t AdvDataLen, uint8_t AdvData[])</td></tr>
<tr class="memdesc:gaff0e0210b67c4fed57edc3e228365a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to update the advertising data for a particular AD type. If the AD type specified does not exist, then it is added to the advertising data. If the overall advertising data length is more than 31 octets after the update, then the command is rejected and the old data is retained.  <a href="group___g_a_p___a_p_i.html#gaff0e0210b67c4fed57edc3e228365a8c">More...</a><br /></td></tr>
<tr class="separator:gaff0e0210b67c4fed57edc3e228365a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25c52a344740f51d8818182e5f4ba2c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga25c52a344740f51d8818182e5f4ba2c0">aci_gap_delete_ad_type</a> (uint8_t ADType)</td></tr>
<tr class="memdesc:ga25c52a344740f51d8818182e5f4ba2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to delete the specified AD type from the advertisement data if present.  <a href="group___g_a_p___a_p_i.html#ga25c52a344740f51d8818182e5f4ba2c0">More...</a><br /></td></tr>
<tr class="separator:ga25c52a344740f51d8818182e5f4ba2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cec916e46fb9e000b119f70d645f5fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga1cec916e46fb9e000b119f70d645f5fa">aci_gap_get_security_level</a> (uint16_t Connection_Handle, uint8_t *Security_Mode, uint8_t *Security_Level)</td></tr>
<tr class="memdesc:ga1cec916e46fb9e000b119f70d645f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to get the current security settings of the device.  <a href="group___g_a_p___a_p_i.html#ga1cec916e46fb9e000b119f70d645f5fa">More...</a><br /></td></tr>
<tr class="separator:ga1cec916e46fb9e000b119f70d645f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d12352d4290eab988acdc90e3da93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gad4d12352d4290eab988acdc90e3da93c">aci_gap_set_event_mask</a> (uint16_t GAP_Evt_Mask)</td></tr>
<tr class="memdesc:gad4d12352d4290eab988acdc90e3da93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It allows masking events from the GAP. The default configuration is all the events masked.  <a href="group___g_a_p___a_p_i.html#gad4d12352d4290eab988acdc90e3da93c">More...</a><br /></td></tr>
<tr class="separator:gad4d12352d4290eab988acdc90e3da93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcca966aeb617fb6c63d6bc400a9037b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gafcca966aeb617fb6c63d6bc400a9037b">aci_gap_configure_whitelist</a> (void)</td></tr>
<tr class="memdesc:gafcca966aeb617fb6c63d6bc400a9037b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add addresses of bonded devices into the controller's whitelist. The command will return an error if there are no devices in the database or if it was unable to add the device into the whitelist.  <a href="group___g_a_p___a_p_i.html#gafcca966aeb617fb6c63d6bc400a9037b">More...</a><br /></td></tr>
<tr class="separator:gafcca966aeb617fb6c63d6bc400a9037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a> (uint16_t Connection_Handle, uint8_t Reason)</td></tr>
<tr class="memdesc:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command the controller to terminate the connection. A <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event will be generated when the link is disconnected. It is important to leave an 100 ms blank window before sending any new command (including system hardware reset), since immediately after <a class="el" href="group___h_c_i__events.html#ga28dfb4e4d94437eac75340723ba42628">hci_disconnection_complete_event</a> event, system could save important information in non volatile memory.  <a href="group___g_a_p___a_p_i.html#ga7c1b1aca7489a846f3aaa25cdb9db180">More...</a><br /></td></tr>
<tr class="separator:ga7c1b1aca7489a846f3aaa25cdb9db180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1909183f16d7de9676a54bab51838569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga1909183f16d7de9676a54bab51838569">aci_gap_clear_security_db</a> (void)</td></tr>
<tr class="memdesc:ga1909183f16d7de9676a54bab51838569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the security database. All the devices in the security database will be removed.  <a href="group___g_a_p___a_p_i.html#ga1909183f16d7de9676a54bab51838569">More...</a><br /></td></tr>
<tr class="separator:ga1909183f16d7de9676a54bab51838569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga76f91fc19683eb9f6ed8d217648b0c82">aci_gap_allow_rebond</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the security manager to complete the pairing procedure and re- bond with the master. This command should be given by the application when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re- bonding to happen successfully. If this command is not given on receiving the event, the bonding procedure will timeout.  <a href="group___g_a_p___a_p_i.html#ga76f91fc19683eb9f6ed8d217648b0c82">More...</a><br /></td></tr>
<tr class="separator:ga76f91fc19683eb9f6ed8d217648b0c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96490c0e5a8d2f3c345b4992e477e403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga96490c0e5a8d2f3c345b4992e477e403">aci_gap_start_limited_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:ga96490c0e5a8d2f3c345b4992e477e403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the limited discovery procedure. The controller is commanded to start active scanning. When this procedure is started, only the devices in limited discoverable mode are returned to the upper layers. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x01 or a timeout happens. When the procedure is terminated due to any of the above reasons, <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to 0x01. The device found when the procedure is ongoing is returned to the upper layers through the event <a class="el" href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">hci_le_advertising_report_event</a>.  <a href="group___g_a_p___a_p_i.html#ga96490c0e5a8d2f3c345b4992e477e403">More...</a><br /></td></tr>
<tr class="separator:ga96490c0e5a8d2f3c345b4992e477e403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed8d0c8a1a23ca240dee0fb895d31df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gaaed8d0c8a1a23ca240dee0fb895d31df">aci_gap_start_general_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:gaaed8d0c8a1a23ca240dee0fb895d31df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the general discovery procedure. The controller is commanded to start active scanning. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x02 or a timeout happens. When the procedure is terminated due to any of the above reasons, <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to 0x02. The device found when the procedure is ongoing is returned to <a class="el" href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">hci_le_advertising_report_event</a>.  <a href="group___g_a_p___a_p_i.html#gaaed8d0c8a1a23ca240dee0fb895d31df">More...</a><br /></td></tr>
<tr class="separator:gaaed8d0c8a1a23ca240dee0fb895d31df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7035c09d3063ca239c4ada8172dc25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gac7035c09d3063ca239c4ada8172dc25e">aci_gap_start_name_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:gac7035c09d3063ca239c4ada8172dc25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the name discovery procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process connectable advertising packets only
       for the specified device". Once a connection is established, GATT procedure is started to read the device name characteristic. When the read is completed (successfully or unsuccessfully), a <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is given to the upper layer. The event also contains the name of the device if the device name was read successfully.  <a href="group___g_a_p___a_p_i.html#gac7035c09d3063ca239c4ada8172dc25e">More...</a><br /></td></tr>
<tr class="separator:gac7035c09d3063ca239c4ada8172dc25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac95e16e25fa07dfc206eeafa1ab33c38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gac95e16e25fa07dfc206eeafa1ab33c38">aci_gap_start_auto_connection_establish_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length, uint8_t Num_of_Whitelist_Entries, <a class="el" href="bluenrg1__api_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:gac95e16e25fa07dfc206eeafa1ab33c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the auto connection establishment procedure. The devices specified are added to the white list of the controller and a LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "use whitelist to determine which
       advertiser to connect to". When a command is issued to terminate the procedure by upper layer, a LE_Create_Connection_Cancel call will be made to the controller by GAP. The procedure is terminated when either a connection is successfully established with one of the specified devices in the white list or the procedure is explicitly terminated by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x08. A <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to 0x08. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___a_p_i.html#gac95e16e25fa07dfc206eeafa1ab33c38">More...</a><br /></td></tr>
<tr class="separator:gac95e16e25fa07dfc206eeafa1ab33c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e87838aa189db795d10a3c4f8e7b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga51e87838aa189db795d10a3c4f8e7b87">aci_gap_start_general_connection_establish_proc</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:ga51e87838aa189db795d10a3c4f8e7b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a general connection establishment procedure. The host enables scanning in the controller with the scanner filter policy set to "accept all advertising packets" and from the scanning results, all the devices are sent to the upper layer using the event LE_Advertising_Report. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#gab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a>. If privacy is enabled, then either a private resolvable address or a non resolvable address, based on the address type specified in the command is set as the scanner address but the gap create connection always uses a private resolvable address if the general connection establishment procedure is active. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x10. On completion of the procedure a <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is generated with the procedure code set to 0x10. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___a_p_i.html#ga51e87838aa189db795d10a3c4f8e7b87">More...</a><br /></td></tr>
<tr class="separator:ga51e87838aa189db795d10a3c4f8e7b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a383c19db7453b5d50e729b01fe6bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gab6a383c19db7453b5d50e729b01fe6bc">aci_gap_start_selective_connection_establish_proc</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy, uint8_t Filter_Duplicates, uint8_t Num_of_Whitelist_Entries, <a class="el" href="bluenrg1__api_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:gab6a383c19db7453b5d50e729b01fe6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a selective connection establishment procedure. The GAP adds the specified device addresses into white list and enables scanning in the controller with the scanner filter policy set to "accept packets only
       from devices in whitelist". All the devices found are sent to the upper layer by the event <a class="el" href="group___h_c_i___l_e__meta__events.html#ga07c3c6ecbaf3113c2161d825e9e03941">hci_le_advertising_report_event</a>. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#gab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a>. On completion of the procedure a <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is generated with the procedure code set to 0x20. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x20. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___a_p_i.html#gab6a383c19db7453b5d50e729b01fe6bc">More...</a><br /></td></tr>
<tr class="separator:gab6a383c19db7453b5d50e729b01fe6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d8d5792788d6cc511c36e1eddabf3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:gab5d8d5792788d6cc511c36e1eddabf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the direct connection establishment procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process
       connectable advertising packets only for the specified device". The procedure can be terminated explicitly by the upper layer by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a>. When a command is issued to terminate the procedure by upper layer, a <a class="el" href="group___h_c_i___a_p_i.html#ga2b2e81b045a7be0ce2eb41b5b5f7b7c2">hci_le_create_connection_cancel</a> call will be made to the controller by GAP. On termination of the procedure, a <a class="el" href="group___h_c_i___l_e__meta__events.html#gaca8160d0515ff237c4c8f4db8e45c77a">hci_le_connection_complete_event</a> event is returned. The procedure can be explicitly terminated by the upper layer by issuing the command <a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure_code set to 0x40. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___a_p_i.html#gab5d8d5792788d6cc511c36e1eddabf3d">More...</a><br /></td></tr>
<tr class="separator:gab5d8d5792788d6cc511c36e1eddabf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39804c69a0cdbd3579b0d3be400665b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> (uint8_t Procedure_Code)</td></tr>
<tr class="memdesc:ga39804c69a0cdbd3579b0d3be400665b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the specified GATT procedure. An <a class="el" href="group___a_c_i___g_a_p__events.html#gab257c9a8c675a353a9c14c587f81342d">aci_gap_proc_complete_event</a> event is returned with the procedure code set to the corresponding procedure.  <a href="group___g_a_p___a_p_i.html#ga39804c69a0cdbd3579b0d3be400665b1">More...</a><br /></td></tr>
<tr class="separator:ga39804c69a0cdbd3579b0d3be400665b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261529d70c766ecd28e9b1464ffb9cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga261529d70c766ecd28e9b1464ffb9cce">aci_gap_start_connection_update</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ga261529d70c766ecd28e9b1464ffb9cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the connection update procedure (only when role is Master). A <a class="el" href="group___h_c_i___a_p_i.html#ga0b1c0e2aede814f82bab64c843710eb8">hci_le_connection_update</a> is called. On completion of the procedure, an <a class="el" href="group___h_c_i___l_e__meta__events.html#ga40b3b0abeb955daefb6b3a860d11e0e9">hci_le_connection_update_complete_event</a> event is returned to the upper layer.  <a href="group___g_a_p___a_p_i.html#ga261529d70c766ecd28e9b1464ffb9cce">More...</a><br /></td></tr>
<tr class="separator:ga261529d70c766ecd28e9b1464ffb9cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52ca818096a284d69d24d3d214f418d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gaf52ca818096a284d69d24d3d214f418d">aci_gap_send_pairing_req</a> (uint16_t Connection_Handle, uint8_t Force_Rebond)</td></tr>
<tr class="memdesc:gaf52ca818096a284d69d24d3d214f418d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the SM pairing request to start a pairing process. The authentication requirements and IO capabilities should be set before issuing this command using the <a class="el" href="group___g_a_p___a_p_i.html#gaf7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> and <a class="el" href="group___g_a_p___a_p_i.html#gad2bee68b2757f1aa0a2034a90b8d2f61">aci_gap_set_authentication_requirement</a> commands. A <a class="el" href="group___a_c_i___g_a_p__events.html#gadc74352ad6c26c693df1390109c55923">aci_gap_pairing_complete_event</a> event is returned after the pairing process is completed.  <a href="group___g_a_p___a_p_i.html#gaf52ca818096a284d69d24d3d214f418d">More...</a><br /></td></tr>
<tr class="separator:gaf52ca818096a284d69d24d3d214f418d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3d4c1303999072f00bbd0440968165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga4c3d4c1303999072f00bbd0440968165">aci_gap_resolve_private_addr</a> (uint8_t Address[6], uint8_t Actual_Address[6])</td></tr>
<tr class="memdesc:ga4c3d4c1303999072f00bbd0440968165"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command tries to resolve the address provided with the IRKs present in its database. If the address is resolved successfully with any one of the IRKs present in the database, it returns success and also the corresponding public/static random address stored with the IRK in the database.  <a href="group___g_a_p___a_p_i.html#ga4c3d4c1303999072f00bbd0440968165">More...</a><br /></td></tr>
<tr class="separator:ga4c3d4c1303999072f00bbd0440968165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a02945421ae32a96d2f2d90b99e6ed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga4a02945421ae32a96d2f2d90b99e6ed7">aci_gap_set_broadcast_mode</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Advertising_Type, uint8_t Own_Address_Type, uint8_t Adv_Data_Length, uint8_t Adv_Data[], uint8_t Num_of_Whitelist_Entries, <a class="el" href="bluenrg1__api_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:ga4a02945421ae32a96d2f2d90b99e6ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command puts the device into broadcast mode. A privacy enabled device uses either a resolvable private address or a non-resolvable private address as specified in the Own_Addr_Type parameter of the command.  <a href="group___g_a_p___a_p_i.html#ga4a02945421ae32a96d2f2d90b99e6ed7">More...</a><br /></td></tr>
<tr class="separator:ga4a02945421ae32a96d2f2d90b99e6ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4943804581004fc2ce3e53a27b891918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga4943804581004fc2ce3e53a27b891918">aci_gap_start_observation_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t LE_Scan_Type, uint8_t Own_Address_Type, uint8_t Filter_Duplicates, uint8_t Scanning_Filter_Policy)</td></tr>
<tr class="memdesc:ga4943804581004fc2ce3e53a27b891918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an Observation procedure, when the device is in Observer Role. The host enables scanning in the controller. The advertising reports are sent to the upper layer using standard LE Advertising Report Event. (See Bluetooth Core v4.1, Vol. 2, part E, Ch. 7.7.65.2, LE Advertising Report Event). If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="group___g_a_p___a_p_i.html#ga4943804581004fc2ce3e53a27b891918">More...</a><br /></td></tr>
<tr class="separator:ga4943804581004fc2ce3e53a27b891918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae335dd4a298252d5735926e31d762041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gae335dd4a298252d5735926e31d762041">aci_gap_get_bonded_devices</a> (uint8_t *Num_of_Addresses, <a class="el" href="bluenrg1__api_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a> Bonded_Device_Entry[])</td></tr>
<tr class="memdesc:gae335dd4a298252d5735926e31d762041"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command gets the list of the devices which are bonded. It returns the number of addresses and the corresponding address types and values. The maximum number of devices that can be returned is MAX_NUM_BONDED_DEVICES (12).  <a href="group___g_a_p___a_p_i.html#gae335dd4a298252d5735926e31d762041">More...</a><br /></td></tr>
<tr class="separator:gae335dd4a298252d5735926e31d762041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#gadf2d88d5dcb1f6dd4f154e29840c96b1">aci_gap_is_device_bonded</a> (uint8_t Peer_Address_Type, uint8_t Peer_Address[6])</td></tr>
<tr class="memdesc:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command finds whether the device, whose address is specified in the command, is bonded. If the device is using a resolvable private address and it has been bonded, then the command will return BLE_STATUS_SUCCESS.  <a href="group___g_a_p___a_p_i.html#gadf2d88d5dcb1f6dd4f154e29840c96b1">More...</a><br /></td></tr>
<tr class="separator:gadf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga53ae1db71ecec2ba7f9dd2992185d935">aci_gap_numeric_comparison_value_confirm_yesno</a> (uint16_t Connection_Handle, uint8_t Confirm_Yes_No)</td></tr>
<tr class="memdesc:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command allows the User to validate/confirm or not the Numeric Comparison value showed through the ACI_GAP_Numeric_Comparison_Value_Event.  <a href="group___g_a_p___a_p_i.html#ga53ae1db71ecec2ba7f9dd2992185d935">More...</a><br /></td></tr>
<tr class="separator:ga53ae1db71ecec2ba7f9dd2992185d935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e97953f93b91e6a94efe65088733ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga22e97953f93b91e6a94efe65088733ed">aci_gap_passkey_input</a> (uint16_t Connection_Handle, uint8_t Input_Type)</td></tr>
<tr class="memdesc:ga22e97953f93b91e6a94efe65088733ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command permits to signal to the Stack the input type detected during Passkey input.  <a href="group___g_a_p___a_p_i.html#ga22e97953f93b91e6a94efe65088733ed">More...</a><br /></td></tr>
<tr class="separator:ga22e97953f93b91e6a94efe65088733ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6d91556b0bc974ff8668befbae3424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga6c6d91556b0bc974ff8668befbae3424">aci_gap_get_oob_data</a> (uint8_t OOB_Data_Type, uint8_t *Address_Type, uint8_t Address[6], uint8_t *OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:ga6c6d91556b0bc974ff8668befbae3424"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent by the User to get (i.e. to extract from the Stack) the OOB data generated by the Stack itself. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager to require the local OOB data (hence without user interaction) to be sent via OOB to the remote peer candidate device. The requested OOB data are returned in response to the incoming command. The OOB data are not generated on the fly, but they are already available in the Stack.  <a href="group___g_a_p___a_p_i.html#ga6c6d91556b0bc974ff8668befbae3424">More...</a><br /></td></tr>
<tr class="separator:ga6c6d91556b0bc974ff8668befbae3424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga0894787f7dd5af1e4f1a7ae1d3844f77">aci_gap_set_oob_data</a> (uint8_t Device_Type, uint8_t Address_Type, uint8_t Address[6], uint8_t OOB_Data_Type, uint8_t OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent (by the User) to input the OOB data arrived via OOB communication. It may be sent to set either the OOB Authentication data of the Local device, or the data received via OOB by the Remote peer candidate device. It can be used with OOB_Data_Len set to 0 to generate OOB authentication data for Secure Connections. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager when receiving the OOB data (hence without user interaction). Since the BLE stack v 2.x implementation supports just one entry for the Remote peer candidate list containing the OOB data, at every command invocation the data existing in that entry are overwritten.  <a href="group___g_a_p___a_p_i.html#ga0894787f7dd5af1e4f1a7ae1d3844f77">More...</a><br /></td></tr>
<tr class="separator:ga0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963958c8154358b7364eaf639f2c4480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga963958c8154358b7364eaf639f2c4480">aci_gap_add_devices_to_resolving_list</a> (uint8_t Num_of_Resolving_list_Entries, <a class="el" href="bluenrg1__api_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a> Whitelist_Identity_Entry[], uint8_t Clear_Resolving_List)</td></tr>
<tr class="memdesc:ga963958c8154358b7364eaf639f2c4480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller.  <a href="group___g_a_p___a_p_i.html#ga963958c8154358b7364eaf639f2c4480">More...</a><br /></td></tr>
<tr class="separator:ga963958c8154358b7364eaf639f2c4480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e986dc4f7bc786707d4102acc3826ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_p___a_p_i.html#ga5e986dc4f7bc786707d4102acc3826ab">aci_gap_remove_bonded_device</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6])</td></tr>
<tr class="memdesc:ga5e986dc4f7bc786707d4102acc3826ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to remove a specified device from the bonding table.  <a href="group___g_a_p___a_p_i.html#ga5e986dc4f7bc786707d4102acc3826ab">More...</a><br /></td></tr>
<tr class="separator:ga5e986dc4f7bc786707d4102acc3826ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae388dcc9bf9bd52339d0b57098988173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gae388dcc9bf9bd52339d0b57098988173">aci_gatt_init</a> (void)</td></tr>
<tr class="memdesc:gae388dcc9bf9bd52339d0b57098988173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the GATT layer for server and client roles. It adds also the GATT service with Service Changed Characteristic. Until this command is issued the GATT channel will not process any commands even if the connection is opened. This command has to be given before using any of the GAP features.  <a href="group___g_a_t_t___a_p_i.html#gae388dcc9bf9bd52339d0b57098988173">More...</a><br /></td></tr>
<tr class="separator:gae388dcc9bf9bd52339d0b57098988173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3232522db120650ac4f92e4ed0a390d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga3232522db120650ac4f92e4ed0a390d6">aci_gatt_add_service</a> (uint8_t Service_UUID_Type, <a class="el" href="bluenrg1__api_8h.html#a4f4bdf54cd7052b0e86de41c615631e9">Service_UUID_t</a> *Service_UUID, uint8_t Service_Type, uint8_t Max_Attribute_Records, uint16_t *Service_Handle)</td></tr>
<tr class="memdesc:ga3232522db120650ac4f92e4ed0a390d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a service to GATT Server. When a service is created in the server, the host needs to reserve the handle ranges for this service using Max_Attribute_Records parameter. This parameter specifies the maximum number of attribute records that can be added to this service (including the service attribute, include attribute, characteristic attribute, characteristic value attribute and characteristic descriptor attribute). Handle of the created service is returned in command complete event. Service declaration is taken from the service pool. The attributes for characteristics and descriptors are allocated from the attribute pool.  <a href="group___g_a_t_t___a_p_i.html#ga3232522db120650ac4f92e4ed0a390d6">More...</a><br /></td></tr>
<tr class="separator:ga3232522db120650ac4f92e4ed0a390d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f076bc9cb0a1f0166fc78adf91f0755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga3f076bc9cb0a1f0166fc78adf91f0755">aci_gatt_include_service</a> (uint16_t Service_Handle, uint16_t Include_Start_Handle, uint16_t Include_End_Handle, uint8_t Include_UUID_Type, <a class="el" href="bluenrg1__api_8h.html#ad25f740382f761d50307a033b0d4b77c">Include_UUID_t</a> *Include_UUID, uint16_t *Include_Handle)</td></tr>
<tr class="memdesc:ga3f076bc9cb0a1f0166fc78adf91f0755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include a service given by Include_Start_Handle and Include_End_Handle to another service given by Service_Handle. Attribute server creates an INCLUDE definition attribute and return the handle of this attribute in Included_handle.  <a href="group___g_a_t_t___a_p_i.html#ga3f076bc9cb0a1f0166fc78adf91f0755">More...</a><br /></td></tr>
<tr class="separator:ga3f076bc9cb0a1f0166fc78adf91f0755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072befcb23bafec72c98e02e6caa0843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga072befcb23bafec72c98e02e6caa0843">aci_gatt_add_char</a> (uint16_t Service_Handle, uint8_t Char_UUID_Type, <a class="el" href="bluenrg1__api_8h.html#ada430e6ce6bfdd7d1d12e7b0a954786e">Char_UUID_t</a> *Char_UUID, uint16_t Char_Value_Length, uint8_t Char_Properties, uint8_t Security_Permissions, uint8_t GATT_Evt_Mask, uint8_t Enc_Key_Size, uint8_t Is_Variable, uint16_t *Char_Handle)</td></tr>
<tr class="memdesc:ga072befcb23bafec72c98e02e6caa0843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a characteristic to a service.  <a href="group___g_a_t_t___a_p_i.html#ga072befcb23bafec72c98e02e6caa0843">More...</a><br /></td></tr>
<tr class="separator:ga072befcb23bafec72c98e02e6caa0843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e9ddca48061e7a369fb3b567fb77fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gad0e9ddca48061e7a369fb3b567fb77fb">aci_gatt_add_char_desc</a> (uint16_t Service_Handle, uint16_t Char_Handle, uint8_t Char_Desc_Uuid_Type, <a class="el" href="bluenrg1__api_8h.html#a9aed71c621c593ebfe257326e0734eb2">Char_Desc_Uuid_t</a> *Char_Desc_Uuid, uint8_t Char_Desc_Value_Max_Len, uint8_t Char_Desc_Value_Length, uint8_t Char_Desc_Value[], uint8_t Security_Permissions, uint8_t Access_Permissions, uint8_t GATT_Evt_Mask, uint8_t Enc_Key_Size, uint8_t Is_Variable, uint16_t *Char_Desc_Handle)</td></tr>
<tr class="memdesc:gad0e9ddca48061e7a369fb3b567fb77fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a characteristic descriptor to a service.  <a href="group___g_a_t_t___a_p_i.html#gad0e9ddca48061e7a369fb3b567fb77fb">More...</a><br /></td></tr>
<tr class="separator:gad0e9ddca48061e7a369fb3b567fb77fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087d6b9bfd793f8eb26dd0768c912b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga087d6b9bfd793f8eb26dd0768c912b59">aci_gatt_update_char_value</a> (uint16_t Service_Handle, uint16_t Char_Handle, uint8_t Val_Offset, uint8_t Char_Value_Length, uint8_t Char_Value[])</td></tr>
<tr class="memdesc:ga087d6b9bfd793f8eb26dd0768c912b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a characteristic value in a service. If notifications (or indications) are enabled on that characteristic, a notification (or indication) will be sent to the client after sending this command to the BlueNRG. The command is queued into the BlueNRG command queue. If the buffer is full, because previous commands could not be still processed, the function will return BLE_STATUS_INSUFFICIENT_RESOURCES. This will happen if notifications (or indications) are enabled and the application calls <a class="el" href="group___g_a_t_t___a_p_i.html#ga087d6b9bfd793f8eb26dd0768c912b59">aci_gatt_update_char_value</a> at an higher rate than what is allowed by the link. Throughput on BLE link depends on connection interval and connection length parameters (decided by the master, see aci_l2cap_connection_parameter_update_request() for more info on how to suggest new connection parameters from a slave). If the application does not want to lose notifications because BlueNRG buffer becomes full, it has to retry again till the function returns BLE_STATUS_SUCCESS or any other error code. DEPRECATED API (still supported but not recommended)  <a href="group___g_a_t_t___a_p_i.html#ga087d6b9bfd793f8eb26dd0768c912b59">More...</a><br /></td></tr>
<tr class="separator:ga087d6b9bfd793f8eb26dd0768c912b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c8aaf0ddff722e0c1f02ed91a3f531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga66c8aaf0ddff722e0c1f02ed91a3f531">aci_gatt_del_char</a> (uint16_t Serv_Handle, uint16_t Char_Handle)</td></tr>
<tr class="memdesc:ga66c8aaf0ddff722e0c1f02ed91a3f531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the specified characteristic from the service.  <a href="group___g_a_t_t___a_p_i.html#ga66c8aaf0ddff722e0c1f02ed91a3f531">More...</a><br /></td></tr>
<tr class="separator:ga66c8aaf0ddff722e0c1f02ed91a3f531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56344efce350e7fd76da5bd15f655a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga56344efce350e7fd76da5bd15f655a69">aci_gatt_del_service</a> (uint16_t Serv_Handle)</td></tr>
<tr class="memdesc:ga56344efce350e7fd76da5bd15f655a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the specified service from the GATT server database.  <a href="group___g_a_t_t___a_p_i.html#ga56344efce350e7fd76da5bd15f655a69">More...</a><br /></td></tr>
<tr class="separator:ga56344efce350e7fd76da5bd15f655a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08285c891c49b59a6f8bd93743b2921a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga08285c891c49b59a6f8bd93743b2921a">aci_gatt_del_include_service</a> (uint16_t Serv_Handle, uint16_t Include_Handle)</td></tr>
<tr class="memdesc:ga08285c891c49b59a6f8bd93743b2921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the Include definition from the service.  <a href="group___g_a_t_t___a_p_i.html#ga08285c891c49b59a6f8bd93743b2921a">More...</a><br /></td></tr>
<tr class="separator:ga08285c891c49b59a6f8bd93743b2921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49669bba524f15e49a6c08234a7ee0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga49669bba524f15e49a6c08234a7ee0ca">aci_gatt_set_event_mask</a> (uint32_t GATT_Evt_Mask)</td></tr>
<tr class="memdesc:ga49669bba524f15e49a6c08234a7ee0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask events from the GATT. The default configuration is all the events masked.  <a href="group___g_a_t_t___a_p_i.html#ga49669bba524f15e49a6c08234a7ee0ca">More...</a><br /></td></tr>
<tr class="separator:ga49669bba524f15e49a6c08234a7ee0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a88b448970051ddc62b190cdef4797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gac0a88b448970051ddc62b190cdef4797">aci_gatt_exchange_config</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:gac0a88b448970051ddc62b190cdef4797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an ATT MTU exchange procedure. When the ATT MTU exchange procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga5fff3f7c776e7b6e51a4c85a08e48a8a">aci_att_exchange_mtu_resp_event</a> event is generated. A <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is also generated to indicate the end of the procedure.  <a href="group___g_a_t_t___a_p_i.html#gac0a88b448970051ddc62b190cdef4797">More...</a><br /></td></tr>
<tr class="separator:gac0a88b448970051ddc62b190cdef4797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c370a4835c2aa0caa7e0f7c7895be23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga5c370a4835c2aa0caa7e0f7c7895be23">aci_att_find_info_req</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle)</td></tr>
<tr class="memdesc:ga5c370a4835c2aa0caa7e0f7c7895be23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a Find Information Request. This command is used to obtain the mapping of attribute handles with their associated types. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaad892136263777daa0b4b4dd89fba199">aci_att_find_info_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga5c370a4835c2aa0caa7e0f7c7895be23">More...</a><br /></td></tr>
<tr class="separator:ga5c370a4835c2aa0caa7e0f7c7895be23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e1bde76a4d586c0461ff6881eab9bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga5e1bde76a4d586c0461ff6881eab9bba">aci_att_find_by_type_value_req</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle, uint16_t UUID, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga5e1bde76a4d586c0461ff6881eab9bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a Find By Type Value Request The Find By Type Value Request is used to obtain the handles of attributes that have a given 16-bit UUID attribute type and a given attribute value. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1f4f154ae328e07d7697de8156a2d79a">aci_att_find_by_type_value_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga5e1bde76a4d586c0461ff6881eab9bba">More...</a><br /></td></tr>
<tr class="separator:ga5e1bde76a4d586c0461ff6881eab9bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf1a025c614e23f766c7575f719475d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gaaaf1a025c614e23f766c7575f719475d">aci_att_read_by_type_req</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg1__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:gaaaf1a025c614e23f766c7575f719475d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a Read By Type Request. The Read By Type Request is used to obtain the values of attributes where the attribute type is known but the handle is not known. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga841972fc8f7925b0ac118acdb6c48ac3">aci_att_read_by_type_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#gaaaf1a025c614e23f766c7575f719475d">More...</a><br /></td></tr>
<tr class="separator:gaaaf1a025c614e23f766c7575f719475d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f05ff7a0933943d516f56ad6a21227d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga3f05ff7a0933943d516f56ad6a21227d">aci_att_read_by_group_type_req</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg1__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:ga3f05ff7a0933943d516f56ad6a21227d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a Read By Group Type Request. The Read By Group Type Request is used to obtain the values of grouping attributes where the attribute type is known but the handle is not known. Grouping attributes are defined at GATT layer. The grouping attribute types are: "Primary
       Service", "Secondary Service" and "Characteristic". The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga910880e84b8504fb1ab150041fe758d5">aci_att_read_by_group_type_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a>.  <a href="group___g_a_t_t___a_p_i.html#ga3f05ff7a0933943d516f56ad6a21227d">More...</a><br /></td></tr>
<tr class="separator:ga3f05ff7a0933943d516f56ad6a21227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537b7754909badb3f536d286bac970fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga537b7754909badb3f536d286bac970fd">aci_att_prepare_write_req</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga537b7754909badb3f536d286bac970fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a Prepare Write Request. The Prepare Write Request is used to request the server to prepare to write the value of an attribute. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga9e0018100c992f384b2547e5db3b65bb">aci_att_prepare_write_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a>.  <a href="group___g_a_t_t___a_p_i.html#ga537b7754909badb3f536d286bac970fd">More...</a><br /></td></tr>
<tr class="separator:ga537b7754909badb3f536d286bac970fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b83dcd787f181afe02debbe2c27ba76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga4b83dcd787f181afe02debbe2c27ba76">aci_att_execute_write_req</a> (uint16_t Connection_Handle, uint8_t Execute)</td></tr>
<tr class="memdesc:ga4b83dcd787f181afe02debbe2c27ba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an Execute Write Request. The Execute Write Request is used to request the server to write or cancel the write of all the prepared values currently held in the prepare queue from this client. The result of the procedure is given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4f9ba360a07c78941cf2311c31253f65">aci_att_exec_write_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga4b83dcd787f181afe02debbe2c27ba76">More...</a><br /></td></tr>
<tr class="separator:ga4b83dcd787f181afe02debbe2c27ba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6202c7e05533beb408eb0f89946269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gadf6202c7e05533beb408eb0f89946269">aci_gatt_disc_all_primary_services</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:gadf6202c7e05533beb408eb0f89946269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the GATT client procedure to discover all primary services on the server. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga910880e84b8504fb1ab150041fe758d5">aci_att_read_by_group_type_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#gadf6202c7e05533beb408eb0f89946269">More...</a><br /></td></tr>
<tr class="separator:gadf6202c7e05533beb408eb0f89946269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1629c6e00623ad74688cd667483c3b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gaa1629c6e00623ad74688cd667483c3b0">aci_gatt_disc_primary_service_by_uuid</a> (uint16_t Connection_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg1__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:gaa1629c6e00623ad74688cd667483c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to discover the primary services of the specified UUID on the server. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga1f4f154ae328e07d7697de8156a2d79a">aci_att_find_by_type_value_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#gaa1629c6e00623ad74688cd667483c3b0">More...</a><br /></td></tr>
<tr class="separator:gaa1629c6e00623ad74688cd667483c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67180282b008b0d40cb593a6ebca7cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gab67180282b008b0d40cb593a6ebca7cc">aci_gatt_find_included_services</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle)</td></tr>
<tr class="memdesc:gab67180282b008b0d40cb593a6ebca7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to find all included services. The responses of the procedure are given through the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga841972fc8f7925b0ac118acdb6c48ac3">aci_att_read_by_type_resp_event</a> event. The end of the procedure is indicated by a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#gab67180282b008b0d40cb593a6ebca7cc">More...</a><br /></td></tr>
<tr class="separator:gab67180282b008b0d40cb593a6ebca7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d45eb9cad7318795258008a8bbfbe26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga7d45eb9cad7318795258008a8bbfbe26">aci_gatt_disc_all_char_of_service</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle)</td></tr>
<tr class="memdesc:ga7d45eb9cad7318795258008a8bbfbe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to discover all the characteristics of a given service. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga841972fc8f7925b0ac118acdb6c48ac3">aci_att_read_by_type_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga7d45eb9cad7318795258008a8bbfbe26">More...</a><br /></td></tr>
<tr class="separator:ga7d45eb9cad7318795258008a8bbfbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71a146c5beb5c7dfdc921977d830c60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gab71a146c5beb5c7dfdc921977d830c60">aci_gatt_disc_char_by_uuid</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg1__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:gab71a146c5beb5c7dfdc921977d830c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to discover all the characteristics specified by a UUID. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga38a6b2ec985535feadb3877ff1c313ca">aci_gatt_disc_read_char_by_uuid_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#gab71a146c5beb5c7dfdc921977d830c60">More...</a><br /></td></tr>
<tr class="separator:gab71a146c5beb5c7dfdc921977d830c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2200e46345c7ef9f11d30028bf51b229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga2200e46345c7ef9f11d30028bf51b229">aci_gatt_disc_all_char_desc</a> (uint16_t Connection_Handle, uint16_t Char_Handle, uint16_t End_Handle)</td></tr>
<tr class="memdesc:ga2200e46345c7ef9f11d30028bf51b229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to discover all characteristic descriptors on the server. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaad892136263777daa0b4b4dd89fba199">aci_att_find_info_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga2200e46345c7ef9f11d30028bf51b229">More...</a><br /></td></tr>
<tr class="separator:ga2200e46345c7ef9f11d30028bf51b229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdff31530e011daa69a42c6f37af4c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gabdff31530e011daa69a42c6f37af4c25">aci_gatt_read_char_value</a> (uint16_t Connection_Handle, uint16_t Attr_Handle)</td></tr>
<tr class="memdesc:gabdff31530e011daa69a42c6f37af4c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to read the attribute value. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packet is given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga0e6667b7b1e3259358cd72899674db62">aci_att_read_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#gabdff31530e011daa69a42c6f37af4c25">More...</a><br /></td></tr>
<tr class="separator:gabdff31530e011daa69a42c6f37af4c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f55db9808b5fead904f373b9c8bbfde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga4f55db9808b5fead904f373b9c8bbfde">aci_gatt_read_using_char_uuid</a> (uint16_t Connection_Handle, uint16_t Start_Handle, uint16_t End_Handle, uint8_t UUID_Type, <a class="el" href="bluenrg1__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a> *UUID)</td></tr>
<tr class="memdesc:ga4f55db9808b5fead904f373b9c8bbfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to read all the characteristics specified by the UUID. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga38a6b2ec985535feadb3877ff1c313ca">aci_gatt_disc_read_char_by_uuid_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga4f55db9808b5fead904f373b9c8bbfde">More...</a><br /></td></tr>
<tr class="separator:ga4f55db9808b5fead904f373b9c8bbfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga638eb79e8871f992e629f38653c2f044"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga638eb79e8871f992e629f38653c2f044">aci_gatt_read_long_char_value</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset)</td></tr>
<tr class="memdesc:ga638eb79e8871f992e629f38653c2f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to read a long characteristic value. the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaffefcf6104370260dc7acdfbecae28f4">aci_att_read_blob_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga638eb79e8871f992e629f38653c2f044">More...</a><br /></td></tr>
<tr class="separator:ga638eb79e8871f992e629f38653c2f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b5b2d644169562b4de494b5421d868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga97b5b2d644169562b4de494b5421d868">aci_gatt_read_multiple_char_value</a> (uint16_t Connection_Handle, uint8_t Number_of_Handles, <a class="el" href="bluenrg1__api_8h.html#a46e49c7305b7ff1d34fec3f2e4bcf42b">Handle_Entry_t</a> Handle_Entry[])</td></tr>
<tr class="memdesc:ga97b5b2d644169562b4de494b5421d868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a procedure to read multiple characteristic values from a server. This sub-procedure is used to read multiple Characteristic Values from a server when the client knows the Characteristic Value Handles. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga549d8fb4169f81ac76f402eaac13301d">aci_att_read_multiple_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga97b5b2d644169562b4de494b5421d868">More...</a><br /></td></tr>
<tr class="separator:ga97b5b2d644169562b4de494b5421d868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3cfb4b3dbed845d314adde7b4ace65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga0c3cfb4b3dbed845d314adde7b4ace65">aci_gatt_write_char_value</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga0c3cfb4b3dbed845d314adde7b4ace65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to write a long characteristic value. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. During the procedure, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga9e0018100c992f384b2547e5db3b65bb">aci_att_prepare_write_resp_event</a> and <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4f9ba360a07c78941cf2311c31253f65">aci_att_exec_write_resp_event</a> events are raised.  <a href="group___g_a_t_t___a_p_i.html#ga0c3cfb4b3dbed845d314adde7b4ace65">More...</a><br /></td></tr>
<tr class="separator:ga0c3cfb4b3dbed845d314adde7b4ace65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be039b58c66f7cc5950c673ca639371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga5be039b58c66f7cc5950c673ca639371">aci_gatt_write_long_char_value</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga5be039b58c66f7cc5950c673ca639371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to write a long characteristic value. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. During the procedure, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga9e0018100c992f384b2547e5db3b65bb">aci_att_prepare_write_resp_event</a> and <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4f9ba360a07c78941cf2311c31253f65">aci_att_exec_write_resp_event</a> events are raised.  <a href="group___g_a_t_t___a_p_i.html#ga5be039b58c66f7cc5950c673ca639371">More...</a><br /></td></tr>
<tr class="separator:ga5be039b58c66f7cc5950c673ca639371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga674c60e57b083c318c50e63cdcc66941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga674c60e57b083c318c50e63cdcc66941">aci_gatt_write_char_reliable</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga674c60e57b083c318c50e63cdcc66941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to write a characteristic reliably. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. During the procedure, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga9e0018100c992f384b2547e5db3b65bb">aci_att_prepare_write_resp_event</a> and <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4f9ba360a07c78941cf2311c31253f65">aci_att_exec_write_resp_event</a> events are raised.  <a href="group___g_a_t_t___a_p_i.html#ga674c60e57b083c318c50e63cdcc66941">More...</a><br /></td></tr>
<tr class="separator:ga674c60e57b083c318c50e63cdcc66941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d2178e5368ffa7b0836f3fd025dde7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gac9d2178e5368ffa7b0836f3fd025dde7">aci_gatt_write_long_char_desc</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:gac9d2178e5368ffa7b0836f3fd025dde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to write a long characteristic descriptor. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. During the procedure, <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga9e0018100c992f384b2547e5db3b65bb">aci_att_prepare_write_resp_event</a> and <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4f9ba360a07c78941cf2311c31253f65">aci_att_exec_write_resp_event</a> events are raised.  <a href="group___g_a_t_t___a_p_i.html#gac9d2178e5368ffa7b0836f3fd025dde7">More...</a><br /></td></tr>
<tr class="separator:gac9d2178e5368ffa7b0836f3fd025dde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadceb493f42a00c7074a2b0d6d435ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gaadceb493f42a00c7074a2b0d6d435ab2">aci_gatt_read_long_char_desc</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint16_t Val_Offset)</td></tr>
<tr class="memdesc:gaadceb493f42a00c7074a2b0d6d435ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to read a long characteristic value. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packets are given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaffefcf6104370260dc7acdfbecae28f4">aci_att_read_blob_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#gaadceb493f42a00c7074a2b0d6d435ab2">More...</a><br /></td></tr>
<tr class="separator:gaadceb493f42a00c7074a2b0d6d435ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647afe941a18a985bcc3f5dbf7363bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga647afe941a18a985bcc3f5dbf7363bcd">aci_gatt_write_char_desc</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga647afe941a18a985bcc3f5dbf7363bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to write a characteristic descriptor. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated.  <a href="group___g_a_t_t___a_p_i.html#ga647afe941a18a985bcc3f5dbf7363bcd">More...</a><br /></td></tr>
<tr class="separator:ga647afe941a18a985bcc3f5dbf7363bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c048c9cd1090368e91ba24905df342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga34c048c9cd1090368e91ba24905df342">aci_gatt_read_char_desc</a> (uint16_t Connection_Handle, uint16_t Attr_Handle)</td></tr>
<tr class="memdesc:ga34c048c9cd1090368e91ba24905df342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to read the descriptor specified. When the procedure is completed, a <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gaa467f454dbfebf1e3ae1bdee3f3b0dd0">aci_gatt_proc_complete_event</a> event is generated. Before procedure completion the response packet is given through <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga0e6667b7b1e3259358cd72899674db62">aci_att_read_resp_event</a> event.  <a href="group___g_a_t_t___a_p_i.html#ga34c048c9cd1090368e91ba24905df342">More...</a><br /></td></tr>
<tr class="separator:ga34c048c9cd1090368e91ba24905df342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade44edf22b4a386bcb4bf36dbb96fc78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gade44edf22b4a386bcb4bf36dbb96fc78">aci_gatt_write_without_resp</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:gade44edf22b4a386bcb4bf36dbb96fc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the procedure to write a characteristic value without waiting for any response from the server. No events are generated after this command is executed.  <a href="group___g_a_t_t___a_p_i.html#gade44edf22b4a386bcb4bf36dbb96fc78">More...</a><br /></td></tr>
<tr class="separator:gade44edf22b4a386bcb4bf36dbb96fc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080609b72caf0b3ff1f17ea9257dfdb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga080609b72caf0b3ff1f17ea9257dfdb6">aci_gatt_signed_write_without_resp</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga080609b72caf0b3ff1f17ea9257dfdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a signed write without response from the server. The procedure is used to write a characteristic value with an authentication signature without waiting for any response from the server. It cannot be used when the link is encrypted.  <a href="group___g_a_t_t___a_p_i.html#ga080609b72caf0b3ff1f17ea9257dfdb6">More...</a><br /></td></tr>
<tr class="separator:ga080609b72caf0b3ff1f17ea9257dfdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048bac8f8f69387d0e5463d394e279d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga048bac8f8f69387d0e5463d394e279d0">aci_gatt_confirm_indication</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga048bac8f8f69387d0e5463d394e279d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow application to confirm indication. This command has to be sent when the application receives the event <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga4105e41bfc5b48723ba048a767e4cac7">aci_gatt_indication_event</a>.  <a href="group___g_a_t_t___a_p_i.html#ga048bac8f8f69387d0e5463d394e279d0">More...</a><br /></td></tr>
<tr class="separator:ga048bac8f8f69387d0e5463d394e279d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602ae12a56126b7e76ae1270e9f21d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga602ae12a56126b7e76ae1270e9f21d64">aci_gatt_write_resp</a> (uint16_t Connection_Handle, uint16_t Attr_Handle, uint8_t Write_status, uint8_t Error_Code, uint8_t Attribute_Val_Length, uint8_t Attribute_Val[])</td></tr>
<tr class="memdesc:ga602ae12a56126b7e76ae1270e9f21d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or reject a write request from a client. This command has to be sent by the application when it receives the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga11dd74c379ab58322dc40a3c667b73f8">aci_gatt_write_permit_req_event</a>. If the write can be allowed, then the status and error code has to be set to 0. If the write cannot be allowed, then the status has to be set to 1 and the error code has to be set to the error code that has to be passed to the client.  <a href="group___g_a_t_t___a_p_i.html#ga602ae12a56126b7e76ae1270e9f21d64">More...</a><br /></td></tr>
<tr class="separator:ga602ae12a56126b7e76ae1270e9f21d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5661814b590763c2753b6aa177d87e00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga5661814b590763c2753b6aa177d87e00">aci_gatt_allow_read</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:ga5661814b590763c2753b6aa177d87e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the GATT server to send a response to a read request from a client. The application has to send this command when it receives the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga663cb4ea2b923dc65b34b5f1385120bd">aci_gatt_read_permit_req_event</a> or <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac9b635444b1e92b76ff6b0688e537cbc">aci_gatt_read_multi_permit_req_event</a>. This command indicates to the stack that the response can be sent to the client. So if the application wishes to update any of the attributes before they are read by the client, it has to update the characteristic values using the <a class="el" href="group___g_a_t_t___a_p_i.html#ga087d6b9bfd793f8eb26dd0768c912b59">aci_gatt_update_char_value</a> and then give this command. The application should perform the required operations within 30 seconds. Otherwise the GATT procedure will be timeout.  <a href="group___g_a_t_t___a_p_i.html#ga5661814b590763c2753b6aa177d87e00">More...</a><br /></td></tr>
<tr class="separator:ga5661814b590763c2753b6aa177d87e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a61c37303c929f3db1750318adb019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gaa7a61c37303c929f3db1750318adb019">aci_gatt_set_security_permission</a> (uint16_t Serv_Handle, uint16_t Attr_Handle, uint8_t Security_Permissions)</td></tr>
<tr class="memdesc:gaa7a61c37303c929f3db1750318adb019"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the security permission for the attribute handle specified. Currently the setting of security permission is allowed only for client configuration descriptor.  <a href="group___g_a_t_t___a_p_i.html#gaa7a61c37303c929f3db1750318adb019">More...</a><br /></td></tr>
<tr class="separator:gaa7a61c37303c929f3db1750318adb019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga742bce845653cc547bc6ed163f19f499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga742bce845653cc547bc6ed163f19f499">aci_gatt_set_desc_value</a> (uint16_t Serv_Handle, uint16_t Char_Handle, uint16_t Char_Desc_Handle, uint16_t Val_Offset, uint8_t Char_Desc_Value_Length, uint8_t Char_Desc_Value[])</td></tr>
<tr class="memdesc:ga742bce845653cc547bc6ed163f19f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the value of the descriptor specified by charDescHandle.  <a href="group___g_a_t_t___a_p_i.html#ga742bce845653cc547bc6ed163f19f499">More...</a><br /></td></tr>
<tr class="separator:ga742bce845653cc547bc6ed163f19f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b7ef371623a24f53824a863aa1b1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga91b7ef371623a24f53824a863aa1b1bd">aci_gatt_read_handle_value</a> (uint16_t Attr_Handle, uint16_t Offset, uint16_t Value_Length_Requested, uint16_t *Length, uint16_t *Value_Length, uint8_t Value[])</td></tr>
<tr class="memdesc:ga91b7ef371623a24f53824a863aa1b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the value of the attribute handle specified from the local GATT database.  <a href="group___g_a_t_t___a_p_i.html#ga91b7ef371623a24f53824a863aa1b1bd">More...</a><br /></td></tr>
<tr class="separator:ga91b7ef371623a24f53824a863aa1b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc9b80cf4d25cc72acc3000b41fc762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga1fc9b80cf4d25cc72acc3000b41fc762">aci_gatt_update_char_value_ext</a> (uint16_t Conn_Handle_To_Notify, uint16_t Service_Handle, uint16_t Char_Handle, uint8_t Update_Type, uint16_t Char_Length, uint16_t Value_Offset, uint8_t Value_Length, uint8_t Value[])</td></tr>
<tr class="memdesc:ga1fc9b80cf4d25cc72acc3000b41fc762"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is a more flexible version of <a class="el" href="group___g_a_t_t___a_p_i.html#ga087d6b9bfd793f8eb26dd0768c912b59">aci_gatt_update_char_value</a> to support update of long attribute up to 512 bytes and indicate selectively the generation of Indication/Notification.  <a href="group___g_a_t_t___a_p_i.html#ga1fc9b80cf4d25cc72acc3000b41fc762">More...</a><br /></td></tr>
<tr class="separator:ga1fc9b80cf4d25cc72acc3000b41fc762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8184d509c7ac89e5b731159fd6dca817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#ga8184d509c7ac89e5b731159fd6dca817">aci_gatt_deny_read</a> (uint16_t Connection_Handle, uint8_t Error_Code)</td></tr>
<tr class="memdesc:ga8184d509c7ac89e5b731159fd6dca817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deny the GATT server to send a response to a read request from a client. The application may send this command when it receives the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga663cb4ea2b923dc65b34b5f1385120bd">aci_gatt_read_permit_req_event</a> or <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac9b635444b1e92b76ff6b0688e537cbc">aci_gatt_read_multi_permit_req_event</a>. This command indicates to the stack that the client is not allowed to read the requested characteristic due to e.g. application restrictions. The Error code shall be either 0x08 (Insufficient Authorization) or a value in the range 0x80-0x9F (Application Error). The application should issue the <a class="el" href="group___g_a_t_t___a_p_i.html#ga8184d509c7ac89e5b731159fd6dca817">aci_gatt_deny_read</a> or <a class="el" href="group___g_a_t_t___a_p_i.html#ga5661814b590763c2753b6aa177d87e00">aci_gatt_allow_read</a> command within 30 seconds from the reception of the <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#ga663cb4ea2b923dc65b34b5f1385120bd">aci_gatt_read_permit_req_event</a> or <a class="el" href="group___a_c_i___g_a_t_t___a_t_t__events.html#gac9b635444b1e92b76ff6b0688e537cbc">aci_gatt_read_multi_permit_req_event</a> events otherwise the GATT procedure will issue a timeout.  <a href="group___g_a_t_t___a_p_i.html#ga8184d509c7ac89e5b731159fd6dca817">More...</a><br /></td></tr>
<tr class="separator:ga8184d509c7ac89e5b731159fd6dca817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea0a489510a903f9e9f30d50d5093601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_a_t_t___a_p_i.html#gaea0a489510a903f9e9f30d50d5093601">aci_gatt_set_access_permission</a> (uint16_t Serv_Handle, uint16_t Attr_Handle, uint8_t Access_Permissions)</td></tr>
<tr class="memdesc:gaea0a489510a903f9e9f30d50d5093601"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command sets the access permission for the attribute handle specified.  <a href="group___g_a_t_t___a_p_i.html#gaea0a489510a903f9e9f30d50d5093601">More...</a><br /></td></tr>
<tr class="separator:gaea0a489510a903f9e9f30d50d5093601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf732199ecbd953e06943ca0aae99805f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___a_p_i.html#gaf732199ecbd953e06943ca0aae99805f">aci_l2cap_connection_parameter_update_req</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Slave_latency, uint16_t Timeout_Multiplier)</td></tr>
<tr class="memdesc:gaf732199ecbd953e06943ca0aae99805f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an L2CAP connection parameter update request from the slave to the master. An <a class="el" href="group___a_c_i___l2_c_a_p__events.html#ga80df69ea3d38af2a53d2cfcbb1e7d4fb">aci_l2cap_connection_update_resp_event</a> event will be raised when the master will respond to the request (accepts or rejects).  <a href="group___l2_c_a_p___a_p_i.html#gaf732199ecbd953e06943ca0aae99805f">More...</a><br /></td></tr>
<tr class="separator:gaf732199ecbd953e06943ca0aae99805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa603559ff3b65676a6d85aaf762dd2f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ble__status_8h.html#a8779d2636708789450ed52739b4e74f3">tBleStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l2_c_a_p___a_p_i.html#gaa603559ff3b65676a6d85aaf762dd2f3">aci_l2cap_connection_parameter_update_resp</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Slave_latency, uint16_t Timeout_Multiplier, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length, uint8_t Identifier, uint8_t Accept)</td></tr>
<tr class="memdesc:gaa603559ff3b65676a6d85aaf762dd2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept or reject a connection update. This command should be sent in response to a <a class="el" href="group___a_c_i___l2_c_a_p__events.html#ga2dee0c664b50509a3ca8477f45b8d5db">aci_l2cap_connection_update_req_event</a> event from the controller. The accept parameter has to be set if the connection parameters given in the event are acceptable.  <a href="group___l2_c_a_p___a_p_i.html#gaa603559ff3b65676a6d85aaf762dd2f3">More...</a><br /></td></tr>
<tr class="separator:gaa603559ff3b65676a6d85aaf762dd2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for BlueNRG-1 Bluetooth Low Energy stack APIs. Autogenerated files, do not edit!! </p>
<dl class="section author"><dt>Author</dt><dd>AMG - RF Application team </dd></dl>
<dl class="section version"><dt>Version</dt><dd>V1.0.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20 February 2020 </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="bluenrg1__api_8h_source.html">bluenrg1_api.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac381829daea9db7081e9594c3a5322ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Bonded_Device_Entry_t </p>

</div>
</div>
<a class="anchor" id="a9aed71c621c593ebfe257326e0734eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_char___desc___uuid__t__s.html">Char_Desc_Uuid_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#a9aed71c621c593ebfe257326e0734eb2">Char_Desc_Uuid_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C union Char_Desc_Uuid_t </p>

</div>
</div>
<a class="anchor" id="ada430e6ce6bfdd7d1d12e7b0a954786e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_char___u_u_i_d__t__s.html">Char_UUID_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#ada430e6ce6bfdd7d1d12e7b0a954786e">Char_UUID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C union Char_UUID_t </p>

</div>
</div>
<a class="anchor" id="a46e49c7305b7ff1d34fec3f2e4bcf42b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_handle___entry__t__s.html">Handle_Entry_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#a46e49c7305b7ff1d34fec3f2e4bcf42b">Handle_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Handle_Entry_t </p>

</div>
</div>
<a class="anchor" id="ad25f740382f761d50307a033b0d4b77c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_include___u_u_i_d__t__s.html">Include_UUID_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#ad25f740382f761d50307a033b0d4b77c">Include_UUID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C union Include_UUID_t </p>

</div>
</div>
<a class="anchor" id="a4f4bdf54cd7052b0e86de41c615631e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_service___u_u_i_d__t__s.html">Service_UUID_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#a4f4bdf54cd7052b0e86de41c615631e9">Service_UUID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C union Service_UUID_t </p>

</div>
</div>
<a class="anchor" id="a2bd9bdce9ac1181c683947604eb96e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_u_u_i_d__t__s.html">UUID_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#a2bd9bdce9ac1181c683947604eb96e44">UUID_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C union UUID_t </p>

</div>
</div>
<a class="anchor" id="a5ad574baee6641a0326ee817f2d278b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Whitelist_Entry_t </p>

</div>
</div>
<a class="anchor" id="a6c91ab8b82c0d7ac0947fad3251cbf45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a>  <a class="el" href="bluenrg1__api_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Whitelist_Identity_Entry_t </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2020 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
