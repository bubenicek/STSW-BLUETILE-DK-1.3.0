<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BlueNRG-1,2 HAL and startup drivers APIs: vtimer.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="STcustom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BlueNRG-1,2 HAL and startup drivers APIs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vtimer.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Virtual timer and Radio timer high level APIs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;BlueNRG1_timer.h&quot;</code><br />
<code>#include &quot;<a class="el" href="vtimer_8h_source.html">vtimer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sleep_8h_source.html">sleep.h</a>&quot;</code><br />
</div>
<p><a href="vtimer_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_a_l___v_t_i_m_e_r___context_s.html">HAL_VTIMER_ContextS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga125af6df2956a88705c7efdba86cabe5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#ga125af6df2956a88705c7efdba86cabe5">ATOMIC_SECTION_BEGIN</a>()</td></tr>
<tr class="separator:ga125af6df2956a88705c7efdba86cabe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfff8120ca5315b54cc5ff907c83902d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#gacfff8120ca5315b54cc5ff907c83902d">ATOMIC_SECTION_END</a>()&#160;&#160;&#160;__set_PRIMASK(uwPRIMASK_Bit)</td></tr>
<tr class="separator:gacfff8120ca5315b54cc5ff907c83902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#gafa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(a,  b)&#160;&#160;&#160;((a) &lt; (b) )? (b) : (a)</td></tr>
<tr class="separator:gafa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#ga3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(a,  b)&#160;&#160;&#160;((a) &gt; (b) )? (b) : (a)</td></tr>
<tr class="separator:ga3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08cdb6ca93f14983cc2ddf0db4464700"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#ga08cdb6ca93f14983cc2ddf0db4464700">DIFF8</a>(a,  b)&#160;&#160;&#160;((a)&gt;=(b) ? ((a)-(b)) : (256-((a)-(b))))</td></tr>
<tr class="separator:ga08cdb6ca93f14983cc2ddf0db4464700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d21259aba8fbe7b2a996018f353d77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#gab3d21259aba8fbe7b2a996018f353d77">INCREMENT_EXPIRE_COUNT_ISR</a>&#160;&#160;&#160;(HAL_VTIMER_Context.expired_count = ((HAL_VTIMER_Context.expired_count + 1) == HAL_VTIMER_Context.served_count) ? HAL_VTIMER_Context.expired_count : (HAL_VTIMER_Context.expired_count + 1))</td></tr>
<tr class="separator:gab3d21259aba8fbe7b2a996018f353d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45249c919484c94cb2de5e232a8a2857"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#ga45249c919484c94cb2de5e232a8a2857">INCREMENT_EXPIRE_COUNT</a>&#160;&#160;&#160;<a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#ga125af6df2956a88705c7efdba86cabe5">ATOMIC_SECTION_BEGIN</a>(); <a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#gab3d21259aba8fbe7b2a996018f353d77">INCREMENT_EXPIRE_COUNT_ISR</a> ; <a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#gacfff8120ca5315b54cc5ff907c83902d">ATOMIC_SECTION_END</a>();</td></tr>
<tr class="separator:ga45249c919484c94cb2de5e232a8a2857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf84f8389ca366e49c25ae74c8b4c16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#gadbf84f8389ca366e49c25ae74c8b4c16">TIMER1_MARGIN</a>&#160;&#160;&#160;9 /*TBD*/</td></tr>
<tr class="separator:gadbf84f8389ca366e49c25ae74c8b4c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8fe244106cd42470148924a013d3de99"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_h_a_l___v_t_i_m_e_r___context_s.html">HAL_VTIMER_ContextS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___types_definitions.html#ga8fe244106cd42470148924a013d3de99">HAL_VTIMER_ContextType</a></td></tr>
<tr class="separator:ga8fe244106cd42470148924a013d3de99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb2416abb83897827ea8430d14e152c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___private___function.html#gacb2416abb83897827ea8430d14e152c9">_check_radio_activity</a> (<a class="el" href="group___v_t_i_m_e_r___exported___types.html#ga086868b0dd0e542f8167e889547c32e8">VTIMER_RadioHandleType</a> *timerHandle, uint8_t *expired)</td></tr>
<tr class="separator:gacb2416abb83897827ea8430d14e152c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d8b105f2bfda39e1ef1b2804ba9882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___v_t_i_m_e_r___exported___types.html#ga0217df3674519b78410e66545b09d6ee">RadioStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gaf1d8b105f2bfda39e1ef1b2804ba9882">HAL_VTimer_GetRadioTimerValue</a> (uint32_t *time)</td></tr>
<tr class="memdesc:gaf1d8b105f2bfda39e1ef1b2804ba9882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status of the radio timer. The timeout of the last radio timer activity taken into account by the Timer Module is saved in the variable passed as parameter.  <a href="group___v_t_i_m_e_r___public___function.html#gaf1d8b105f2bfda39e1ef1b2804ba9882">More...</a><br /></td></tr>
<tr class="separator:gaf1d8b105f2bfda39e1ef1b2804ba9882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294de6476d1b923b32c6281640609826"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga294de6476d1b923b32c6281640609826">HAL_VTimer_ClearRadioTimerValue</a> (void)</td></tr>
<tr class="memdesc:ga294de6476d1b923b32c6281640609826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the last radio activity scheduled disabling the radio timer too. Furthermore, it returns if the timeout is too close with respect the current time and the radio activity might not be cleared in time.  <a href="group___v_t_i_m_e_r___public___function.html#ga294de6476d1b923b32c6281640609826">More...</a><br /></td></tr>
<tr class="separator:ga294de6476d1b923b32c6281640609826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2266d78ab1fdc199cc33271cf57a7328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga2266d78ab1fdc199cc33271cf57a7328">HAL_VTimer_StopRadioTimer2</a> (void)</td></tr>
<tr class="memdesc:ga2266d78ab1fdc199cc33271cf57a7328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Timer2.  <a href="group___v_t_i_m_e_r___public___function.html#ga2266d78ab1fdc199cc33271cf57a7328">More...</a><br /></td></tr>
<tr class="separator:ga2266d78ab1fdc199cc33271cf57a7328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340e1a2a0814d3cd0e4c424128a77b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga340e1a2a0814d3cd0e4c424128a77b73">HAL_VTIMER_TimeoutCallback</a> (void)</td></tr>
<tr class="memdesc:ga340e1a2a0814d3cd0e4c424128a77b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual timer Timeout Callback. It must be called in the Blue handler if the host wake up timer bit in the radio controller interrupt/status register is active.  <a href="group___v_t_i_m_e_r___public___function.html#ga340e1a2a0814d3cd0e4c424128a77b73">More...</a><br /></td></tr>
<tr class="separator:ga340e1a2a0814d3cd0e4c424128a77b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a0ed22841524238fa069e90858a3d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga57a0ed22841524238fa069e90858a3d5">HAL_VTIMER_RadioTimerIsr</a> (void)</td></tr>
<tr class="memdesc:ga57a0ed22841524238fa069e90858a3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radio activity finished. Not used yet.  <a href="group___v_t_i_m_e_r___public___function.html#ga57a0ed22841524238fa069e90858a3d5">More...</a><br /></td></tr>
<tr class="separator:ga57a0ed22841524238fa069e90858a3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d553aaf09e4c134b63d6218b26ff832"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga6d553aaf09e4c134b63d6218b26ff832">HAL_VTimerStart_sysT32</a> (<a class="el" href="group___v_t_i_m_e_r___exported___types.html#ga24fbc47210eb8b0010f855360f8aae97">VTIMER_HandleType</a> *timerHandle, uint64_t time)</td></tr>
<tr class="memdesc:ga6d553aaf09e4c134b63d6218b26ff832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a one-shot virtual timer for the given absolute timeout value expressed in internal time units.  <a href="group___v_t_i_m_e_r___public___function.html#ga6d553aaf09e4c134b63d6218b26ff832">More...</a><br /></td></tr>
<tr class="separator:ga6d553aaf09e4c134b63d6218b26ff832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ae05e6e7406c14a693c319169a86e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga94ae05e6e7406c14a693c319169a86e2">HAL_VTimerStart_ms</a> (<a class="el" href="group___v_t_i_m_e_r___exported___types.html#ga24fbc47210eb8b0010f855360f8aae97">VTIMER_HandleType</a> *timerHandle, uint32_t msRelTimeout)</td></tr>
<tr class="memdesc:ga94ae05e6e7406c14a693c319169a86e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a one-shot virtual timer for the given relative timeout value expressed in ms.  <a href="group___v_t_i_m_e_r___public___function.html#ga94ae05e6e7406c14a693c319169a86e2">More...</a><br /></td></tr>
<tr class="separator:ga94ae05e6e7406c14a693c319169a86e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb09adc35bd80510ff420b0cdcc16aea"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gadb09adc35bd80510ff420b0cdcc16aea">HAL_VTimer_SetRadioTimerValue</a> (uint32_t time, uint8_t event_type, uint8_t cal_req)</td></tr>
<tr class="memdesc:gadb09adc35bd80510ff420b0cdcc16aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a radio activity for the given absolute timeout value expressed in STU If the calibration of the low speed oscillator is needed, if it is possible, the radio timer will be programmed with the latest calibration data.  <a href="group___v_t_i_m_e_r___public___function.html#gadb09adc35bd80510ff420b0cdcc16aea">More...</a><br /></td></tr>
<tr class="separator:gadb09adc35bd80510ff420b0cdcc16aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga587f3c1112d65c7fea9f0d94af5735ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga587f3c1112d65c7fea9f0d94af5735ad">HAL_VTimer_Stop</a> (<a class="el" href="group___v_t_i_m_e_r___exported___types.html#ga24fbc47210eb8b0010f855360f8aae97">VTIMER_HandleType</a> *timerHandle)</td></tr>
<tr class="memdesc:ga587f3c1112d65c7fea9f0d94af5735ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the one-shot virtual timer specified if found.  <a href="group___v_t_i_m_e_r___public___function.html#ga587f3c1112d65c7fea9f0d94af5735ad">More...</a><br /></td></tr>
<tr class="separator:ga587f3c1112d65c7fea9f0d94af5735ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bc6fc6411987df78053675f51f4a14"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gad6bc6fc6411987df78053675f51f4a14">HAL_VTimerGetCurrentTime_sysT32</a> (void)</td></tr>
<tr class="memdesc:gad6bc6fc6411987df78053675f51f4a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function return the current reference time expressed in system time units. The returned value can be used as absolute time parameter where needed in the other HAL_VTimer* APIs.  <a href="group___v_t_i_m_e_r___public___function.html#gad6bc6fc6411987df78053675f51f4a14">More...</a><br /></td></tr>
<tr class="separator:gad6bc6fc6411987df78053675f51f4a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a3825461350990147c342fb0eab229"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gad8a3825461350990147c342fb0eab229">HAL_VTIMER_GetAnchorPoint</a> (void)</td></tr>
<tr class="memdesc:gad8a3825461350990147c342fb0eab229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last anchorPoint in system time unit.  <a href="group___v_t_i_m_e_r___public___function.html#gad8a3825461350990147c342fb0eab229">More...</a><br /></td></tr>
<tr class="separator:gad8a3825461350990147c342fb0eab229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f41587a748ade10ee700ac65996701"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gaf9f41587a748ade10ee700ac65996701">HAL_VTimerAcc_sysT32_ms</a> (uint64_t sysTime, int32_t msTime)</td></tr>
<tr class="memdesc:gaf9f41587a748ade10ee700ac65996701"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the sum of an absolute time and a signed relative time.  <a href="group___v_t_i_m_e_r___public___function.html#gaf9f41587a748ade10ee700ac65996701">More...</a><br /></td></tr>
<tr class="separator:gaf9f41587a748ade10ee700ac65996701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd324aaa270ffdfc73718161a97d7bb2"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gafd324aaa270ffdfc73718161a97d7bb2">HAL_VTimerDiff_ms_sysT32</a> (uint64_t sysTime1, uint64_t sysTime2)</td></tr>
<tr class="memdesc:gafd324aaa270ffdfc73718161a97d7bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference between two absolute times: sysTime1-sysTime2. The resulting value is expressed in ms.  <a href="group___v_t_i_m_e_r___public___function.html#gafd324aaa270ffdfc73718161a97d7bb2">More...</a><br /></td></tr>
<tr class="separator:gafd324aaa270ffdfc73718161a97d7bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae717b1000872fd901c77e60a74e72e0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gae717b1000872fd901c77e60a74e72e0a">HAL_VTimerExpiry_sysT32</a> (<a class="el" href="group___v_t_i_m_e_r___exported___types.html#ga24fbc47210eb8b0010f855360f8aae97">VTIMER_HandleType</a> *timerHandle, uint64_t *sysTime)</td></tr>
<tr class="memdesc:gae717b1000872fd901c77e60a74e72e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute expiry time of a running timer expressed in internal time units.  <a href="group___v_t_i_m_e_r___public___function.html#gae717b1000872fd901c77e60a74e72e0a">More...</a><br /></td></tr>
<tr class="separator:gae717b1000872fd901c77e60a74e72e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cad075d6ec15937f981dc558823047e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga9cad075d6ec15937f981dc558823047e">HAL_VTIMER_GetPendingTimers</a> (void)</td></tr>
<tr class="memdesc:ga9cad075d6ec15937f981dc558823047e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of timers in the queue.  <a href="group___v_t_i_m_e_r___public___function.html#ga9cad075d6ec15937f981dc558823047e">More...</a><br /></td></tr>
<tr class="separator:ga9cad075d6ec15937f981dc558823047e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed9b6ad8c982914c2b804700241b7e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gaed9b6ad8c982914c2b804700241b7e0b">HAL_VTIMER_Init</a> (<a class="el" href="group___v_t_i_m_e_r___exported___types.html#ga23c9080d3865a514041fe1f71d9cc673">HAL_VTIMER_InitType</a> *HAL_TIMER_InitStruct)</td></tr>
<tr class="memdesc:gaed9b6ad8c982914c2b804700241b7e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the timer module. It must be placed in the initialization section of the application.  <a href="group___v_t_i_m_e_r___public___function.html#gaed9b6ad8c982914c2b804700241b7e0b">More...</a><br /></td></tr>
<tr class="separator:gaed9b6ad8c982914c2b804700241b7e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e0fa8ea7b066acf8f2299d2cb73ae19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga3e0fa8ea7b066acf8f2299d2cb73ae19">HAL_VTIMER_Tick</a> (void)</td></tr>
<tr class="memdesc:ga3e0fa8ea7b066acf8f2299d2cb73ae19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer module state machine. Check and schedule the calibration. Check expired timers and execute user callback. It must be placed inside the infinite loop.  <a href="group___v_t_i_m_e_r___public___function.html#ga3e0fa8ea7b066acf8f2299d2cb73ae19">More...</a><br /></td></tr>
<tr class="separator:ga3e0fa8ea7b066acf8f2299d2cb73ae19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1e1a3648d2f813f4dfcfa082e046bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sleep_8h.html#ace58749df14c14b64252eb55f40d2c32">SleepModes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#gae1e1a3648d2f813f4dfcfa082e046bd6">HAL_VTIMER_TimerSleepCheck</a> (<a class="el" href="sleep_8h.html#ace58749df14c14b64252eb55f40d2c32">SleepModes</a> sleepMode)</td></tr>
<tr class="memdesc:gae1e1a3648d2f813f4dfcfa082e046bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the admitted sleep mode according to the next timer activity.  <a href="group___v_t_i_m_e_r___public___function.html#gae1e1a3648d2f813f4dfcfa082e046bd6">More...</a><br /></td></tr>
<tr class="separator:gae1e1a3648d2f813f4dfcfa082e046bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236b610f92796d381fa23b6f21d08913"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_t_i_m_e_r___public___function.html#ga236b610f92796d381fa23b6f21d08913">HAL_VTIMER_SleepCheck</a> (void)</td></tr>
<tr class="memdesc:ga236b610f92796d381fa23b6f21d08913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the consensus of the Virtual timer management to go in sleep.  <a href="group___v_t_i_m_e_r___public___function.html#ga236b610f92796d381fa23b6f21d08913">More...</a><br /></td></tr>
<tr class="separator:ga236b610f92796d381fa23b6f21d08913"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Virtual timer and Radio timer high level APIs. </p>
<dl class="section warning"><dt>Warning</dt><dd>This module must not be included in applications based on the BLE stack library. In that case, the API implementation is managed by the library itself. The API calls remain the same. In the future release the BLE stack library will rely on the Timer module library. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>RF Application Team </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jan-2020</dd></dl>
<p>This file implements the software layer that provides the virtualization of the resources of a single hardware timer in order to allocate many user virtual timers. Each instance of a virtual timer is placed in an queue ordered by the expiration time and it can be linked to a callback. The timer tick is in charge to execute the callback linked to each virtual timer and to update the hardware timeout to gurantee the expiration of the next virtual timer in the queue. A special virtual timer called calibration/anti-wrapping timer is automatically armed by the software. This timer can address two tasks:</p><ul>
<li>it is in charge to maintain the never wrapping virtual time base.</li>
<li>if the slow clock calibration is enabled, it starts the calibration procedure at each calibration interval specified during the initialization.</li>
</ul>
<p>A timer is intended as an event programmed in the future at a certain absolute expiration time on a time base. In this implementation the time base grows on 64 bits. Then, it never wraps. However, due to hardware timer finite length and in order to maintain the timing coherency, the time base must be maintained at least one time before the hardware timer wraps. Then even if the slow clock calibration is disabled, the calibration/anti-wrapping timer is always active with the only role to maintain the time base and it will expire at a rate that depends on the hardware timer capability. The time base unit is a STU that is the unit exposed to the user and it is equal to 625/256 us. The calibration/anti-wrapping mechanism is not managed by the user.</p>
<p>This software layer also exposes the possibility to program a radio timer. A radio timer allows the user to trigger an already configured radio event. This layer tries to exploit the last calibration values to program the radio activity in order to improve the accuracy. In this case, the radio event is not immediately programmed when it is requested, but only when the next calibration values are available. Since the calibration values are available inside the timer tick when the calibration is over, the application must ensure that the timer tick is called after the calibration timer expiration within a certain margin in order to avoid that the radio event is shifted in the past and cannot be anymore programmed.</p>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT 2020 STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="vtimer_8c_source.html">vtimer.c</a>.</p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2020 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
