<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>STM32L - BlueNRG-1,2 BLE stack APIs, Events and Constants: bluenrg1_gap_aci.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="STcustom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STM32L - BlueNRG-1,2 BLE stack APIs, Events and Constants
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bluenrg1_gap_aci.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for external uC - BlueNRG-x in network coprocessor mode (gap_aci) Autogenerated files, do not edit!!  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;bluenrg1_types.h&quot;</code><br />
</div>
<p><a href="bluenrg1__gap__aci_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5ad574baee6641a0326ee817f2d278b4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a></td></tr>
<tr class="separator:a5ad574baee6641a0326ee817f2d278b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac381829daea9db7081e9594c3a5322ea"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a></td></tr>
<tr class="separator:ac381829daea9db7081e9594c3a5322ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c91ab8b82c0d7ac0947fad3251cbf45"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a></td></tr>
<tr class="separator:a6c91ab8b82c0d7ac0947fad3251cbf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa04d32f0009ee0df4fbe4643c4e593a5"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#aa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> (void)</td></tr>
<tr class="memdesc:aa04d32f0009ee0df4fbe4643c4e593a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in non-discoverable mode. This command disables the LL advertising.  <a href="#aa04d32f0009ee0df4fbe4643c4e593a5">More...</a><br /></td></tr>
<tr class="separator:aa04d32f0009ee0df4fbe4643c4e593a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472bbcc86d4f3b87615733a0c22bdd9"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a1472bbcc86d4f3b87615733a0c22bdd9">aci_gap_set_limited_discoverable</a> (uint8_t Advertising_Type, uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Advertising_Filter_Policy, uint8_t Local_Name_Length, uint8_t Local_Name[], uint8_t Service_Uuid_length, uint8_t Service_Uuid_List[], uint16_t Slave_Conn_Interval_Min, uint16_t Slave_Conn_Interval_Max)</td></tr>
<tr class="memdesc:a1472bbcc86d4f3b87615733a0c22bdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in limited discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.3). The device will be discoverable for maximum period of TGAP (lim_adv_timeout) = 180 seconds (from errata). The advertising can be disabled at any time by issuing <a class="el" href="bluenrg1__gap__aci_8h.html#aa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP will use default values for adv intervals for limited discoverable mode (250 ms and 500 ms respectively). To allow a fast connection, the host can set Local_Name, Service_Uuid_List, Slave_Conn_Interval_Min and Slave_Conn_Interval_Max. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be set in advertised data using GAP_Update_Adv_Data command separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - Power Level When advertising timeout happens (i.e. limited discovery period has elapsed), controller generates aci_gap_limited_discoverable_event event.  <a href="#a1472bbcc86d4f3b87615733a0c22bdd9">More...</a><br /></td></tr>
<tr class="separator:a1472bbcc86d4f3b87615733a0c22bdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1795e7e98ac1e1165238b143a06dd3"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a6b1795e7e98ac1e1165238b143a06dd3">aci_gap_set_discoverable</a> (uint8_t Advertising_Type, uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Advertising_Filter_Policy, uint8_t Local_Name_Length, uint8_t Local_Name[], uint8_t Service_Uuid_length, uint8_t Service_Uuid_List[], uint16_t Slave_Conn_Interval_Min, uint16_t Slave_Conn_Interval_Max)</td></tr>
<tr class="memdesc:a6b1795e7e98ac1e1165238b143a06dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device in general discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.4). The device will be discoverable until the host issues the <a class="el" href="bluenrg1__gap__aci_8h.html#aa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP uses the default values for adv intervals for general discoverable mode. When using connectable undirected advertising events: - Adv_Interval_Min = 30 ms - Adv_Interval_Max = 60 ms When using non- connectable advertising events or scannable undirected advertising events: - Adv_Interval_Min = 100 ms - Adv_Interval_Max = 150 ms Host can set the Local Name, a Service UUID list and the Slave Connection Interval Range. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be also set using <a class="el" href="bluenrg1__gap__aci_8h.html#aff0e0210b67c4fed57edc3e228365a8c" title="This command can be used to update the advertising data for a particular AD type. If the AD type spec...">aci_gap_update_adv_data()</a> separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - TX Power Level.  <a href="#a6b1795e7e98ac1e1165238b143a06dd3">More...</a><br /></td></tr>
<tr class="separator:a6b1795e7e98ac1e1165238b143a06dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e333853ba4eb3b6e94f2acdf7597cce"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a8e333853ba4eb3b6e94f2acdf7597cce">aci_gap_set_direct_connectable</a> (uint8_t Own_Address_Type, uint8_t Directed_Advertising_Type, uint8_t Direct_Address_Type, uint8_t Direct_Address[6], uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max)</td></tr>
<tr class="memdesc:a8e333853ba4eb3b6e94f2acdf7597cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device in direct connectable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.3.3). Device uses direct connectable mode to advertise using High Duty cycle advertisement events or Low Duty cycle advertisement events and the address as either what is specified in the Own Address Type parameter. The command specifies the type of the advertising used. If the privacy is enabled, the Type parameter in reconnection address is used for advertising, otherwise the address of the type specified in OwnAddrType is used. The device will be in directed connectable mode only for 1.28 seconds. If no connection is established within this duration, the device enters non discoverable mode and advertising will have to be again enabled explicitly. The controller generates a hci_le_connection_complete_event event with the status set to 0x3C (Directed Advertising Timeout) if the connection was not established and 0x00 if the connection was successfully established. If Host privacy (i.e. privacy 1.1) is enabled this command returns BLE_STATUS_INVALID_PARAMS.  <a href="#a8e333853ba4eb3b6e94f2acdf7597cce">More...</a><br /></td></tr>
<tr class="separator:a8e333853ba4eb3b6e94f2acdf7597cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e39b68644bdc0149ea9270427715cd"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#af7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> (uint8_t IO_Capability)</td></tr>
<tr class="memdesc:af7e39b68644bdc0149ea9270427715cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the IO capabilities of the device. This command has to be given only when the device is not in a connected state.  <a href="#af7e39b68644bdc0149ea9270427715cd">More...</a><br /></td></tr>
<tr class="separator:af7e39b68644bdc0149ea9270427715cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bee68b2757f1aa0a2034a90b8d2f61"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ad2bee68b2757f1aa0a2034a90b8d2f61">aci_gap_set_authentication_requirement</a> (uint8_t Bonding_Mode, uint8_t MITM_Mode, uint8_t SC_Support, uint8_t KeyPress_Notification_Support, uint8_t Min_Encryption_Key_Size, uint8_t Max_Encryption_Key_Size, uint8_t Use_Fixed_Pin, uint32_t Fixed_Pin, uint8_t Identity_Address_Type)</td></tr>
<tr class="memdesc:ad2bee68b2757f1aa0a2034a90b8d2f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authentication requirements for the device. This command has to be given only when the device is not in a connected state.  <a href="#ad2bee68b2757f1aa0a2034a90b8d2f61">More...</a><br /></td></tr>
<tr class="separator:ad2bee68b2757f1aa0a2034a90b8d2f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafb71362ebef8fec2dc0c10a05c92e0"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#acafb71362ebef8fec2dc0c10a05c92e0">aci_gap_set_authorization_requirement</a> (uint16_t Connection_Handle, uint8_t Authorization_Enable)</td></tr>
<tr class="memdesc:acafb71362ebef8fec2dc0c10a05c92e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the authorization requirements of the device. This command has to be given when connected to a device if authorization is required to access services which require authorization.  <a href="#acafb71362ebef8fec2dc0c10a05c92e0">More...</a><br /></td></tr>
<tr class="separator:acafb71362ebef8fec2dc0c10a05c92e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5acbb617b13a0880a76d8f063153e6f"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ab5acbb617b13a0880a76d8f063153e6f">aci_gap_pass_key_resp</a> (uint16_t Connection_Handle, uint32_t Pass_Key)</td></tr>
<tr class="memdesc:ab5acbb617b13a0880a76d8f063153e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command should be send by the host in response to aci_gap_pass_key_req_event event. The command parameter contains the pass key which will be used during the pairing process.  <a href="#ab5acbb617b13a0880a76d8f063153e6f">More...</a><br /></td></tr>
<tr class="separator:ab5acbb617b13a0880a76d8f063153e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f00c7d04afae40779a36b27684f840"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a14f00c7d04afae40779a36b27684f840">aci_gap_authorization_resp</a> (uint16_t Connection_Handle, uint8_t Authorize)</td></tr>
<tr class="memdesc:a14f00c7d04afae40779a36b27684f840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authorize a device to access attributes. This command should be send by the host in response to aci_gap_authorization_req_event event.  <a href="#a14f00c7d04afae40779a36b27684f840">More...</a><br /></td></tr>
<tr class="separator:a14f00c7d04afae40779a36b27684f840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8135485b2fce4116c825e226b43046"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#afc8135485b2fce4116c825e226b43046">aci_gap_init</a> (uint8_t Role, uint8_t privacy_enabled, uint8_t device_name_char_len, uint16_t *Service_Handle, uint16_t *Dev_Name_Char_Handle, uint16_t *Appearance_Char_Handle)</td></tr>
<tr class="memdesc:afc8135485b2fce4116c825e226b43046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristics will also be added: - Device Name - Appearance - Peripheral Preferred Connection Parameters (peripheral role only) WARNING: A section of the Flash memory (pointed by stored_device_id_data_p) is used by this procedure. When this section is empty, data are written inside. This normally happens once during the lifetime of the device, when the command is executed for the first time (or every time it is called after that section has been erased). Do not power off the device while this function is writing into Flash memory. If the functions returns FLASH_WRITE_FAILED, it means that the flash area pointed by stored_device_id_data_p is corrupted (probably due to a power loss during the first call to <a class="el" href="bluenrg1__gap__aci_8h.html#afc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a>). To fix the problem, that flash area has to be erased, so that the <a class="el" href="bluenrg1__gap__aci_8h.html#afc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a> can reinitialize it correctly.  <a href="#afc8135485b2fce4116c825e226b43046">More...</a><br /></td></tr>
<tr class="separator:afc8135485b2fce4116c825e226b43046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7581dbd49beb7d43c2c28a21bd352e6"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#af7581dbd49beb7d43c2c28a21bd352e6">aci_gap_set_non_connectable</a> (uint8_t Advertising_Event_Type, uint8_t Own_Address_Type)</td></tr>
<tr class="memdesc:af7581dbd49beb7d43c2c28a21bd352e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device into non connectable mode. This mode does not support connection. The privacy setting done in the <a class="el" href="bluenrg1__gap__aci_8h.html#afc8135485b2fce4116c825e226b43046">aci_gap_init</a> command plays a role in deciding the valid parameters for this command. Advertiser filter policy is internally set to 0x00.  <a href="#af7581dbd49beb7d43c2c28a21bd352e6">More...</a><br /></td></tr>
<tr class="separator:af7581dbd49beb7d43c2c28a21bd352e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212b78100bc3c64553036247fa612bb"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a2212b78100bc3c64553036247fa612bb">aci_gap_set_undirected_connectable</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Own_Address_Type, uint8_t Adv_Filter_Policy)</td></tr>
<tr class="memdesc:a2212b78100bc3c64553036247fa612bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the device into undirected connectable mode. If privacy is enabled in the device, a resolvable private address is generated and used as the advertiser's address. If not, the address of the type specified in own_addr_type is used for advertising.  <a href="#a2212b78100bc3c64553036247fa612bb">More...</a><br /></td></tr>
<tr class="separator:a2212b78100bc3c64553036247fa612bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80162feee4f10fbfce5099ba0a7a61ba"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a80162feee4f10fbfce5099ba0a7a61ba">aci_gap_slave_security_req</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:a80162feee4f10fbfce5099ba0a7a61ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a slave security request to the master. This command has to be issued to notify the master of the security requirements of the slave. The master may encrypt the link, initiate the pairing procedure, or reject the request.  <a href="#a80162feee4f10fbfce5099ba0a7a61ba">More...</a><br /></td></tr>
<tr class="separator:a80162feee4f10fbfce5099ba0a7a61ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0e0210b67c4fed57edc3e228365a8c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#aff0e0210b67c4fed57edc3e228365a8c">aci_gap_update_adv_data</a> (uint8_t AdvDataLen, uint8_t AdvData[])</td></tr>
<tr class="memdesc:aff0e0210b67c4fed57edc3e228365a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to update the advertising data for a particular AD type. If the AD type specified does not exist, then it is added to the advertising data. If the overall advertising data length is more than 31 octets after the update, then the command is rejected and the old data is retained.  <a href="#aff0e0210b67c4fed57edc3e228365a8c">More...</a><br /></td></tr>
<tr class="separator:aff0e0210b67c4fed57edc3e228365a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c52a344740f51d8818182e5f4ba2c0"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a25c52a344740f51d8818182e5f4ba2c0">aci_gap_delete_ad_type</a> (uint8_t ADType)</td></tr>
<tr class="memdesc:a25c52a344740f51d8818182e5f4ba2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to delete the specified AD type from the advertisement data if present.  <a href="#a25c52a344740f51d8818182e5f4ba2c0">More...</a><br /></td></tr>
<tr class="separator:a25c52a344740f51d8818182e5f4ba2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cec916e46fb9e000b119f70d645f5fa"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a1cec916e46fb9e000b119f70d645f5fa">aci_gap_get_security_level</a> (uint16_t Connection_Handle, uint8_t *Security_Mode, uint8_t *Security_Level)</td></tr>
<tr class="memdesc:a1cec916e46fb9e000b119f70d645f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to get the current security settings of the device.  <a href="#a1cec916e46fb9e000b119f70d645f5fa">More...</a><br /></td></tr>
<tr class="separator:a1cec916e46fb9e000b119f70d645f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d12352d4290eab988acdc90e3da93c"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ad4d12352d4290eab988acdc90e3da93c">aci_gap_set_event_mask</a> (uint16_t GAP_Evt_Mask)</td></tr>
<tr class="memdesc:ad4d12352d4290eab988acdc90e3da93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It allows masking events from the GAP. The default configuration is all the events masked.  <a href="#ad4d12352d4290eab988acdc90e3da93c">More...</a><br /></td></tr>
<tr class="separator:ad4d12352d4290eab988acdc90e3da93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcca966aeb617fb6c63d6bc400a9037b"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#afcca966aeb617fb6c63d6bc400a9037b">aci_gap_configure_whitelist</a> (void)</td></tr>
<tr class="memdesc:afcca966aeb617fb6c63d6bc400a9037b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add addresses of bonded devices into the controller's whitelist. The command will return an error if there are no devices in the database or if it was unable to add the device into the whitelist.  <a href="#afcca966aeb617fb6c63d6bc400a9037b">More...</a><br /></td></tr>
<tr class="separator:afcca966aeb617fb6c63d6bc400a9037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1b1aca7489a846f3aaa25cdb9db180"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a7c1b1aca7489a846f3aaa25cdb9db180">aci_gap_terminate</a> (uint16_t Connection_Handle, uint8_t Reason)</td></tr>
<tr class="memdesc:a7c1b1aca7489a846f3aaa25cdb9db180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command the controller to terminate the connection. A hci_disconnection_complete_event event will be generated when the link is disconnected. It is important to leave an 100 ms blank window before sending any new command (including system hardware reset), since immediately after hci_disconnection_complete_event event, system could save important information in non volatile memory.  <a href="#a7c1b1aca7489a846f3aaa25cdb9db180">More...</a><br /></td></tr>
<tr class="separator:a7c1b1aca7489a846f3aaa25cdb9db180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1909183f16d7de9676a54bab51838569"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a1909183f16d7de9676a54bab51838569">aci_gap_clear_security_db</a> (void)</td></tr>
<tr class="memdesc:a1909183f16d7de9676a54bab51838569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the security database. All the devices in the security database will be removed.  <a href="#a1909183f16d7de9676a54bab51838569">More...</a><br /></td></tr>
<tr class="separator:a1909183f16d7de9676a54bab51838569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f91fc19683eb9f6ed8d217648b0c82"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a76f91fc19683eb9f6ed8d217648b0c82">aci_gap_allow_rebond</a> (uint16_t Connection_Handle)</td></tr>
<tr class="memdesc:a76f91fc19683eb9f6ed8d217648b0c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the security manager to complete the pairing procedure and re- bond with the master. This command should be given by the application when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re- bonding to happen successfully. If this command is not given on receiving the event, the bonding procedure will timeout.  <a href="#a76f91fc19683eb9f6ed8d217648b0c82">More...</a><br /></td></tr>
<tr class="separator:a76f91fc19683eb9f6ed8d217648b0c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96490c0e5a8d2f3c345b4992e477e403"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a96490c0e5a8d2f3c345b4992e477e403">aci_gap_start_limited_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:a96490c0e5a8d2f3c345b4992e477e403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the limited discovery procedure. The controller is commanded to start active scanning. When this procedure is started, only the devices in limited discoverable mode are returned to the upper layers. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x01 or a timeout happens. When the procedure is terminated due to any of the above reasons, aci_gap_proc_complete_event event is returned with the procedure code set to 0x01. The device found when the procedure is ongoing is returned to the upper layers through the event hci_le_advertising_report_event.  <a href="#a96490c0e5a8d2f3c345b4992e477e403">More...</a><br /></td></tr>
<tr class="separator:a96490c0e5a8d2f3c345b4992e477e403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed8d0c8a1a23ca240dee0fb895d31df"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#aaed8d0c8a1a23ca240dee0fb895d31df">aci_gap_start_general_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:aaed8d0c8a1a23ca240dee0fb895d31df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the general discovery procedure. The controller is commanded to start active scanning. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x02 or a timeout happens. When the procedure is terminated due to any of the above reasons, aci_gap_proc_complete_event event is returned with the procedure code set to 0x02. The device found when the procedure is ongoing is returned to hci_le_advertising_report_event.  <a href="#aaed8d0c8a1a23ca240dee0fb895d31df">More...</a><br /></td></tr>
<tr class="separator:aaed8d0c8a1a23ca240dee0fb895d31df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7035c09d3063ca239c4ada8172dc25e"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ac7035c09d3063ca239c4ada8172dc25e">aci_gap_start_name_discovery_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ac7035c09d3063ca239c4ada8172dc25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the name discovery procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process connectable advertising packets only
       for the specified device". Once a connection is established, GATT procedure is started to read the device name characteristic. When the read is completed (successfully or unsuccessfully), a aci_gap_proc_complete_event event is given to the upper layer. The event also contains the name of the device if the device name was read successfully.  <a href="#ac7035c09d3063ca239c4ada8172dc25e">More...</a><br /></td></tr>
<tr class="separator:ac7035c09d3063ca239c4ada8172dc25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95e16e25fa07dfc206eeafa1ab33c38"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ac95e16e25fa07dfc206eeafa1ab33c38">aci_gap_start_auto_connection_establish_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length, uint8_t Num_of_Whitelist_Entries, <a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:ac95e16e25fa07dfc206eeafa1ab33c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the auto connection establishment procedure. The devices specified are added to the white list of the controller and a LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "use whitelist to determine which
       advertiser to connect to". When a command is issued to terminate the procedure by upper layer, a LE_Create_Connection_Cancel call will be made to the controller by GAP. The procedure is terminated when either a connection is successfully established with one of the specified devices in the white list or the procedure is explicitly terminated by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x08. A aci_gap_proc_complete_event event is returned with the procedure code set to 0x08. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="#ac95e16e25fa07dfc206eeafa1ab33c38">More...</a><br /></td></tr>
<tr class="separator:ac95e16e25fa07dfc206eeafa1ab33c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e87838aa189db795d10a3c4f8e7b87"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a51e87838aa189db795d10a3c4f8e7b87">aci_gap_start_general_connection_establish_proc</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy, uint8_t Filter_Duplicates)</td></tr>
<tr class="memdesc:a51e87838aa189db795d10a3c4f8e7b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a general connection establishment procedure. The host enables scanning in the controller with the scanner filter policy set to "accept all advertising packets" and from the scanning results, all the devices are sent to the upper layer using the event LE_Advertising_Report. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#ab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a>. If privacy is enabled, then either a private resolvable address or a non resolvable address, based on the address type specified in the command is set as the scanner address but the gap create connection always uses a private resolvable address if the general connection establishment procedure is active. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x10. On completion of the procedure a aci_gap_proc_complete_event event is generated with the procedure code set to 0x10. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="#a51e87838aa189db795d10a3c4f8e7b87">More...</a><br /></td></tr>
<tr class="separator:a51e87838aa189db795d10a3c4f8e7b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a383c19db7453b5d50e729b01fe6bc"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ab6a383c19db7453b5d50e729b01fe6bc">aci_gap_start_selective_connection_establish_proc</a> (uint8_t LE_Scan_Type, uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Own_Address_Type, uint8_t Scanning_Filter_Policy, uint8_t Filter_Duplicates, uint8_t Num_of_Whitelist_Entries, <a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:ab6a383c19db7453b5d50e729b01fe6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a selective connection establishment procedure. The GAP adds the specified device addresses into white list and enables scanning in the controller with the scanner filter policy set to "accept packets only
       from devices in whitelist". All the devices found are sent to the upper layer by the event hci_le_advertising_report_event. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#ab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a>. On completion of the procedure a aci_gap_proc_complete_event event is generated with the procedure code set to 0x20. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x20. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="#ab6a383c19db7453b5d50e729b01fe6bc">More...</a><br /></td></tr>
<tr class="separator:ab6a383c19db7453b5d50e729b01fe6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d8d5792788d6cc511c36e1eddabf3d"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t Peer_Address_Type, uint8_t Peer_Address[6], uint8_t Own_Address_Type, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:ab5d8d5792788d6cc511c36e1eddabf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the direct connection establishment procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process
       connectable advertising packets only for the specified device". The procedure can be terminated explicitly by the upper layer by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a>. When a command is issued to terminate the procedure by upper layer, a <a class="el" href="bluenrg1__hci__le_8h.html#a2b2e81b045a7be0ce2eb41b5b5f7b7c2">hci_le_create_connection_cancel</a> call will be made to the controller by GAP. On termination of the procedure, a hci_le_connection_complete_event event is returned. The procedure can be explicitly terminated by the upper layer by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure_code set to 0x40. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="#ab5d8d5792788d6cc511c36e1eddabf3d">More...</a><br /></td></tr>
<tr class="separator:ab5d8d5792788d6cc511c36e1eddabf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39804c69a0cdbd3579b0d3be400665b1"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> (uint8_t Procedure_Code)</td></tr>
<tr class="memdesc:a39804c69a0cdbd3579b0d3be400665b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the specified GATT procedure. An aci_gap_proc_complete_event event is returned with the procedure code set to the corresponding procedure.  <a href="#a39804c69a0cdbd3579b0d3be400665b1">More...</a><br /></td></tr>
<tr class="separator:a39804c69a0cdbd3579b0d3be400665b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261529d70c766ecd28e9b1464ffb9cce"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a261529d70c766ecd28e9b1464ffb9cce">aci_gap_start_connection_update</a> (uint16_t Connection_Handle, uint16_t Conn_Interval_Min, uint16_t Conn_Interval_Max, uint16_t Conn_Latency, uint16_t Supervision_Timeout, uint16_t Minimum_CE_Length, uint16_t Maximum_CE_Length)</td></tr>
<tr class="memdesc:a261529d70c766ecd28e9b1464ffb9cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the connection update procedure (only when role is Master). A <a class="el" href="bluenrg1__hci__le_8h.html#a0b1c0e2aede814f82bab64c843710eb8">hci_le_connection_update</a> is called. On completion of the procedure, an hci_le_connection_update_complete_event event is returned to the upper layer.  <a href="#a261529d70c766ecd28e9b1464ffb9cce">More...</a><br /></td></tr>
<tr class="separator:a261529d70c766ecd28e9b1464ffb9cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ca818096a284d69d24d3d214f418d"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#af52ca818096a284d69d24d3d214f418d">aci_gap_send_pairing_req</a> (uint16_t Connection_Handle, uint8_t Force_Rebond)</td></tr>
<tr class="memdesc:af52ca818096a284d69d24d3d214f418d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the SM pairing request to start a pairing process. The authentication requirements and IO capabilities should be set before issuing this command using the <a class="el" href="bluenrg1__gap__aci_8h.html#af7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> and <a class="el" href="bluenrg1__gap__aci_8h.html#ad2bee68b2757f1aa0a2034a90b8d2f61">aci_gap_set_authentication_requirement</a> commands. A aci_gap_pairing_complete_event event is returned after the pairing process is completed.  <a href="#af52ca818096a284d69d24d3d214f418d">More...</a><br /></td></tr>
<tr class="separator:af52ca818096a284d69d24d3d214f418d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3d4c1303999072f00bbd0440968165"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a4c3d4c1303999072f00bbd0440968165">aci_gap_resolve_private_addr</a> (uint8_t Address[6], uint8_t Actual_Address[6])</td></tr>
<tr class="memdesc:a4c3d4c1303999072f00bbd0440968165"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command tries to resolve the address provided with the IRKs present in its database. If the address is resolved successfully with any one of the IRKs present in the database, it returns success and also the corresponding public/static random address stored with the IRK in the database.  <a href="#a4c3d4c1303999072f00bbd0440968165">More...</a><br /></td></tr>
<tr class="separator:a4c3d4c1303999072f00bbd0440968165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a02945421ae32a96d2f2d90b99e6ed7"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a4a02945421ae32a96d2f2d90b99e6ed7">aci_gap_set_broadcast_mode</a> (uint16_t Advertising_Interval_Min, uint16_t Advertising_Interval_Max, uint8_t Advertising_Type, uint8_t Own_Address_Type, uint8_t Adv_Data_Length, uint8_t Adv_Data[], uint8_t Num_of_Whitelist_Entries, <a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> Whitelist_Entry[])</td></tr>
<tr class="memdesc:a4a02945421ae32a96d2f2d90b99e6ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command puts the device into broadcast mode. A privacy enabled device uses either a resolvable private address or a non-resolvable private address as specified in the Own_Addr_Type parameter of the command.  <a href="#a4a02945421ae32a96d2f2d90b99e6ed7">More...</a><br /></td></tr>
<tr class="separator:a4a02945421ae32a96d2f2d90b99e6ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4943804581004fc2ce3e53a27b891918"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a4943804581004fc2ce3e53a27b891918">aci_gap_start_observation_proc</a> (uint16_t LE_Scan_Interval, uint16_t LE_Scan_Window, uint8_t LE_Scan_Type, uint8_t Own_Address_Type, uint8_t Filter_Duplicates, uint8_t Scanning_Filter_Policy)</td></tr>
<tr class="memdesc:a4943804581004fc2ce3e53a27b891918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an Observation procedure, when the device is in Observer Role. The host enables scanning in the controller. The advertising reports are sent to the upper layer using standard LE Advertising Report Event. (See Bluetooth Core v4.1, Vol. 2, part E, Ch. 7.7.65.2, LE Advertising Report Event). If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used.  <a href="#a4943804581004fc2ce3e53a27b891918">More...</a><br /></td></tr>
<tr class="separator:a4943804581004fc2ce3e53a27b891918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae335dd4a298252d5735926e31d762041"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#ae335dd4a298252d5735926e31d762041">aci_gap_get_bonded_devices</a> (uint8_t *Num_of_Addresses, <a class="el" href="bluenrg1__gap__aci_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a> Bonded_Device_Entry[])</td></tr>
<tr class="memdesc:ae335dd4a298252d5735926e31d762041"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command gets the list of the devices which are bonded. It returns the number of addresses and the corresponding address types and values. The maximum number of devices that can be returned is MAX_NUM_BONDED_DEVICES (12).  <a href="#ae335dd4a298252d5735926e31d762041">More...</a><br /></td></tr>
<tr class="separator:ae335dd4a298252d5735926e31d762041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#adf2d88d5dcb1f6dd4f154e29840c96b1">aci_gap_is_device_bonded</a> (uint8_t Peer_Address_Type, uint8_t Peer_Address[6])</td></tr>
<tr class="memdesc:adf2d88d5dcb1f6dd4f154e29840c96b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command finds whether the device, whose address is specified in the command, is bonded. If the device is using a resolvable private address and it has been bonded, then the command will return BLE_STATUS_SUCCESS.  <a href="#adf2d88d5dcb1f6dd4f154e29840c96b1">More...</a><br /></td></tr>
<tr class="separator:adf2d88d5dcb1f6dd4f154e29840c96b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ae1db71ecec2ba7f9dd2992185d935"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a53ae1db71ecec2ba7f9dd2992185d935">aci_gap_numeric_comparison_value_confirm_yesno</a> (uint16_t Connection_Handle, uint8_t Confirm_Yes_No)</td></tr>
<tr class="memdesc:a53ae1db71ecec2ba7f9dd2992185d935"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command allows the User to validate/confirm or not the Numeric Comparison value showed through the ACI_GAP_Numeric_Comparison_Value_Event.  <a href="#a53ae1db71ecec2ba7f9dd2992185d935">More...</a><br /></td></tr>
<tr class="separator:a53ae1db71ecec2ba7f9dd2992185d935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e97953f93b91e6a94efe65088733ed"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a22e97953f93b91e6a94efe65088733ed">aci_gap_passkey_input</a> (uint16_t Connection_Handle, uint8_t Input_Type)</td></tr>
<tr class="memdesc:a22e97953f93b91e6a94efe65088733ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command permits to signal to the Stack the input type detected during Passkey input.  <a href="#a22e97953f93b91e6a94efe65088733ed">More...</a><br /></td></tr>
<tr class="separator:a22e97953f93b91e6a94efe65088733ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6d91556b0bc974ff8668befbae3424"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a6c6d91556b0bc974ff8668befbae3424">aci_gap_get_oob_data</a> (uint8_t OOB_Data_Type, uint8_t *Address_Type, uint8_t Address[6], uint8_t *OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:a6c6d91556b0bc974ff8668befbae3424"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent by the User to get (i.e. to extract from the Stack) the OOB data generated by the Stack itself. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager to require the local OOB data (hence without user interaction) to be sent via OOB to the remote peer candidate device. The requested OOB data are returned in response to the incoming command. The OOB data are not generated on the fly, but they are already available in the Stack.  <a href="#a6c6d91556b0bc974ff8668befbae3424">More...</a><br /></td></tr>
<tr class="separator:a6c6d91556b0bc974ff8668befbae3424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a0894787f7dd5af1e4f1a7ae1d3844f77">aci_gap_set_oob_data</a> (uint8_t Device_Type, uint8_t Address_Type, uint8_t Address[6], uint8_t OOB_Data_Type, uint8_t OOB_Data_Len, uint8_t OOB_Data[16])</td></tr>
<tr class="memdesc:a0894787f7dd5af1e4f1a7ae1d3844f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is sent (by the User) to input the OOB data arrived via OOB communication. It may be sent to set either the OOB Authentication data of the Local device, or the data received via OOB by the Remote peer candidate device. It can be used with OOB_Data_Len set to 0 to generate OOB authentication data for Secure Connections. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager when receiving the OOB data (hence without user interaction). Since the BLE stack v 2.x implementation supports just one entry for the Remote peer candidate list containing the OOB data, at every command invocation the data existing in that entry are overwritten.  <a href="#a0894787f7dd5af1e4f1a7ae1d3844f77">More...</a><br /></td></tr>
<tr class="separator:a0894787f7dd5af1e4f1a7ae1d3844f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963958c8154358b7364eaf639f2c4480"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a963958c8154358b7364eaf639f2c4480">aci_gap_add_devices_to_resolving_list</a> (uint8_t Num_of_Resolving_list_Entries, <a class="el" href="bluenrg1__gap__aci_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a> Whitelist_Identity_Entry[], uint8_t Clear_Resolving_List)</td></tr>
<tr class="memdesc:a963958c8154358b7364eaf639f2c4480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller.  <a href="#a963958c8154358b7364eaf639f2c4480">More...</a><br /></td></tr>
<tr class="separator:a963958c8154358b7364eaf639f2c4480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e986dc4f7bc786707d4102acc3826ab"><td class="memItemLeft" align="right" valign="top">tBleStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bluenrg1__gap__aci_8h.html#a5e986dc4f7bc786707d4102acc3826ab">aci_gap_remove_bonded_device</a> (uint8_t Peer_Identity_Address_Type, uint8_t Peer_Identity_Address[6])</td></tr>
<tr class="memdesc:a5e986dc4f7bc786707d4102acc3826ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can be used to remove a specified device from the bonding table.  <a href="#a5e986dc4f7bc786707d4102acc3826ab">More...</a><br /></td></tr>
<tr class="separator:a5e986dc4f7bc786707d4102acc3826ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for external uC - BlueNRG-x in network coprocessor mode (gap_aci) Autogenerated files, do not edit!! </p>
<dl class="section author"><dt>Author</dt><dd>AMG - RF Application team </dd></dl>
<dl class="section date"><dt>Date</dt><dd>20 February 2020 </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<p>THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.</p>
<h2><center>&copy; COPYRIGHT STMicroelectronics</center></h2>

<p>Definition in file <a class="el" href="bluenrg1__gap__aci_8h_source.html">bluenrg1_gap_aci.h</a>.</p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac381829daea9db7081e9594c3a5322ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_bonded___device___entry__t__s.html">Bonded_Device_Entry_t_s</a>  <a class="el" href="bluenrg1__gap__aci_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Bonded_Device_Entry_t </p>

</div>
</div>
<a class="anchor" id="a5ad574baee6641a0326ee817f2d278b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_whitelist___entry__t__s.html">Whitelist_Entry_t_s</a>  <a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Whitelist_Entry_t </p>

</div>
</div>
<a class="anchor" id="a6c91ab8b82c0d7ac0947fad3251cbf45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_whitelist___identity___entry__t__s.html">Whitelist_Identity_Entry_t_s</a>  <a class="el" href="bluenrg1__gap__aci_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Documentation for C struct Whitelist_Identity_Entry_t </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a963958c8154358b7364eaf639f2c4480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_add_devices_to_resolving_list </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Num_of_Resolving_list_Entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bluenrg1__gap__aci_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a>&#160;</td>
          <td class="paramname"><em>Whitelist_Identity_Entry</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Clear_Resolving_List</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command is used to add one device to the list of address translations used to resolve Resolvable Private Addresses in the Controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Num_of_Resolving_list_Entries</td><td>Number of devices that have to be added to the resolving list. </td></tr>
    <tr><td class="paramname">Whitelist_Identity_Entry</td><td>See <a class="el" href="bluenrg1__gap__aci_8h.html#a6c91ab8b82c0d7ac0947fad3251cbf45">Whitelist_Identity_Entry_t</a> </td></tr>
    <tr><td class="paramname">Clear_Resolving_List</td><td>Clear the resolving list before adding the devices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76f91fc19683eb9f6ed8d217648b0c82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_allow_rebond </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the security manager to complete the pairing procedure and re- bond with the master. This command should be given by the application when it receives the ACI_GAP_BOND_LOST_EVENT if it wants the re- bonding to happen successfully. If this command is not given on receiving the event, the bonding procedure will timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14f00c7d04afae40779a36b27684f840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_authorization_resp </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Authorize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Authorize a device to access attributes. This command should be send by the host in response to aci_gap_authorization_req_event event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Authorize</td><td>Authorization response. Values:<ul>
<li>0x01: Authorize</li>
<li>0x02: Reject </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1909183f16d7de9676a54bab51838569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_clear_security_db </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the security database. All the devices in the security database will be removed. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcca966aeb617fb6c63d6bc400a9037b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_configure_whitelist </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add addresses of bonded devices into the controller's whitelist. The command will return an error if there are no devices in the database or if it was unable to add the device into the whitelist. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5d8d5792788d6cc511c36e1eddabf3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_create_connection </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Address</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Latency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Supervision_Timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Minimum_CE_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Maximum_CE_Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the direct connection establishment procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process
       connectable advertising packets only for the specified device". The procedure can be terminated explicitly by the upper layer by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a>. When a command is issued to terminate the procedure by upper layer, a <a class="el" href="bluenrg1__hci__le_8h.html#a2b2e81b045a7be0ce2eb41b5b5f7b7c2">hci_le_create_connection_cancel</a> call will be made to the controller by GAP. On termination of the procedure, a hci_le_connection_complete_event event is returned. The procedure can be explicitly terminated by the upper layer by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure_code set to 0x40. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address_Type</td><td>Peer Address type. Values:<ul>
<li>0x00: Public Device Address or Public Identity Address</li>
<li>0x01: Random Device Address or Random (static) Identity Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address</td><td>Public Device Address, Random Device Address, Public Identity Address or Random (static) Identity Address of the advertising device. </td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Min</td><td>Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Max</td><td>Maximum value for the connection event interval. This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Supervision_Timeout</td><td>Supervision timeout for the LE Link. It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 msec. Values:<ul>
<li>0x000A (100 ms) ... 0x0C80 (32000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Minimum_CE_Length</td><td>Information parameter about the minimum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
    <tr><td class="paramname">Maximum_CE_Length</td><td>Information parameter about the maximum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25c52a344740f51d8818182e5f4ba2c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_delete_ad_type </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ADType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command can be used to delete the specified AD type from the advertisement data if present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADType</td><td>One of the AD types like in Bluetooth specification (see volume 3, Part C, 11.1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae335dd4a298252d5735926e31d762041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_get_bonded_devices </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>Num_of_Addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bluenrg1__gap__aci_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a>&#160;</td>
          <td class="paramname"><em>Bonded_Device_Entry</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command gets the list of the devices which are bonded. It returns the number of addresses and the corresponding address types and values. The maximum number of devices that can be returned is MAX_NUM_BONDED_DEVICES (12). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Num_of_Addresses</td><td>The number of bonded devices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Bonded_Device_Entry</td><td>See <a class="el" href="bluenrg1__gap__aci_8h.html#ac381829daea9db7081e9594c3a5322ea">Bonded_Device_Entry_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c6d91556b0bc974ff8668befbae3424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_get_oob_data </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>OOB_Data_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Address</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>OOB_Data_Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>OOB_Data</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command is sent by the User to get (i.e. to extract from the Stack) the OOB data generated by the Stack itself. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager to require the local OOB data (hence without user interaction) to be sent via OOB to the remote peer candidate device. The requested OOB data are returned in response to the incoming command. The OOB data are not generated on the fly, but they are already available in the Stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">OOB_Data_Type</td><td>OOB Data type. - 0x00: Legacy Privacy (LP) v.4.1 TK (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r used for generation of Confirm - 0x02: Secure Connections (SC) v.4.2 Confirm value C generated through AES-CMAC-128 based cryptographic function: C=f4(PKx, PKx, r, 0) Values:<ul>
<li>0x00: SM_TK</li>
<li>0x01: SM_RANDOM_VALUE</li>
<li>0x02: SM_CONFIRM_VALUE </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Address_Type</td><td>Identity address type. Values:<ul>
<li>0x00: Public Identity Address</li>
<li>0x01: Random (static) Identity Address </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Address</td><td>Public or Random (static) address of this device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OOB_Data_Len</td><td>Length of OOB Data carried by next data field </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OOB_Data</td><td>OOB Data to be exported via OOB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cec916e46fb9e000b119f70d645f5fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_get_security_level </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>Security_Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>Security_Level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command can be used to get the current security settings of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Security_Mode</td><td>Security mode. Values:<ul>
<li>0x01: Security Mode 1</li>
<li>0x02: Security Mode 2 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Security_Level</td><td>Security Level. Values:<ul>
<li>0x01: Security Level 1</li>
<li>0x02: Security Level 2</li>
<li>0x03: Security Level 3</li>
<li>0x04: Security Level 4 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc8135485b2fce4116c825e226b43046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_init </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>privacy_enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>device_name_char_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>Service_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>Dev_Name_Char_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>Appearance_Char_Handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristics will also be added: - Device Name - Appearance - Peripheral Preferred Connection Parameters (peripheral role only) WARNING: A section of the Flash memory (pointed by stored_device_id_data_p) is used by this procedure. When this section is empty, data are written inside. This normally happens once during the lifetime of the device, when the command is executed for the first time (or every time it is called after that section has been erased). Do not power off the device while this function is writing into Flash memory. If the functions returns FLASH_WRITE_FAILED, it means that the flash area pointed by stored_device_id_data_p is corrupted (probably due to a power loss during the first call to <a class="el" href="bluenrg1__gap__aci_8h.html#afc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a>). To fix the problem, that flash area has to be erased, so that the <a class="el" href="bluenrg1__gap__aci_8h.html#afc8135485b2fce4116c825e226b43046" title="Initialize the GAP layer. Register the GAP service with the GATT. All the standard GAP characteristic...">aci_gap_init()</a> can reinitialize it correctly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Role</td><td>Bitmap of allowed roles. Flags:<ul>
<li>0x01: Peripheral</li>
<li>0x02: Broadcaster</li>
<li>0x04: Central</li>
<li>0x08: Observer </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">privacy_enabled</td><td>Specify if privacy is enabled or not and which one . Values:<ul>
<li>0x00: Privacy disabled</li>
<li>0x01: Privacy host enabled</li>
<li>0x02: Privacy controller enabled </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">device_name_char_len</td><td>Length of the device name characteristic Values:<ul>
<li>0 ... 248 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Service_Handle</td><td>Handle of the GAP service </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Dev_Name_Char_Handle</td><td>Device Name Characteristic handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Appearance_Char_Handle</td><td>Appearance Characteristic handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf2d88d5dcb1f6dd4f154e29840c96b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_is_device_bonded </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Address</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The command finds whether the device, whose address is specified in the command, is bonded. If the device is using a resolvable private address and it has been bonded, then the command will return BLE_STATUS_SUCCESS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Peer_Address_Type</td><td>Address type. Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address</td><td>Address used by the peer device while advertising </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53ae1db71ecec2ba7f9dd2992185d935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_numeric_comparison_value_confirm_yesno </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Confirm_Yes_No</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command allows the User to validate/confirm or not the Numeric Comparison value showed through the ACI_GAP_Numeric_Comparison_Value_Event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Confirm_Yes_No</td><td>0 : The Numeric Values showed on both local and peer device are different! 1 : The Numeric Values showed on both local and peer device are equal! Values:<ul>
<li>0x00: No</li>
<li>0x01: YES </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5acbb617b13a0880a76d8f063153e6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_pass_key_resp </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Pass_Key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command should be send by the host in response to aci_gap_pass_key_req_event event. The command parameter contains the pass key which will be used during the pairing process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Pass_Key</td><td>Pass key that will be used during the pairing process. Must be a six-digit decimal number. Values:<ul>
<li>0 ... 999999 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22e97953f93b91e6a94efe65088733ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_passkey_input </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Input_Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command permits to signal to the Stack the input type detected during Passkey input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Input_Type</td><td>Passkey input type detected Values:<ul>
<li>0x00: Passkey entry started</li>
<li>0x01: Passkey digit entered</li>
<li>0x02: Passkey digit erased</li>
<li>0x03: Passkey cleared</li>
<li>0x04: Passkey entry completed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e986dc4f7bc786707d4102acc3826ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_remove_bonded_device </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Identity_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Identity_Address</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command can be used to remove a specified device from the bonding table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Peer_Identity_Address_Type</td><td>Identity address type. Values:<ul>
<li>0x00: Public Identity Address</li>
<li>0x01: Random (static) Identity Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Identity_Address</td><td>Public or Random (static) Identity address of the peer device </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c3d4c1303999072f00bbd0440968165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_resolve_private_addr </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Address</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Actual_Address</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command tries to resolve the address provided with the IRKs present in its database. If the address is resolved successfully with any one of the IRKs present in the database, it returns success and also the corresponding public/static random address stored with the IRK in the database. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Address</td><td>Address to be resolved </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Actual_Address</td><td>The public or static random address of the peer device, distributed during pairing phase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af52ca818096a284d69d24d3d214f418d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_send_pairing_req </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Force_Rebond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the SM pairing request to start a pairing process. The authentication requirements and IO capabilities should be set before issuing this command using the <a class="el" href="bluenrg1__gap__aci_8h.html#af7e39b68644bdc0149ea9270427715cd">aci_gap_set_io_capability</a> and <a class="el" href="bluenrg1__gap__aci_8h.html#ad2bee68b2757f1aa0a2034a90b8d2f61">aci_gap_set_authentication_requirement</a> commands. A aci_gap_pairing_complete_event event is returned after the pairing process is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Force_Rebond</td><td>If 1, Pairing request will be sent even if the device was previously bonded, otherwise pairing request is not sent. Values:<ul>
<li>0x00: NO</li>
<li>0x01: YES </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2bee68b2757f1aa0a2034a90b8d2f61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_authentication_requirement </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Bonding_Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>MITM_Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>SC_Support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>KeyPress_Notification_Support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Min_Encryption_Key_Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Max_Encryption_Key_Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Use_Fixed_Pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Fixed_Pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Identity_Address_Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the authentication requirements for the device. This command has to be given only when the device is not in a connected state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Bonding_Mode</td><td>Bonding mode. Only if bonding is enabled (0x01), the bonding information is stored in flash Values:<ul>
<li>0x00: NO_BONDING</li>
<li>0x01: BONDING </li>
</ul>
</td></tr>
    <tr><td class="paramname">MITM_Mode</td><td>MITM mode. Values:<ul>
<li>0x00: MITM_PROTECTION_NOT_REQUIRED</li>
<li>0x01: MITM_PROTECTION_REQUIRED </li>
</ul>
</td></tr>
    <tr><td class="paramname">SC_Support</td><td>LE Secure connections support. - 0x00: Secure Connections Pairing not supported - 0x01: Secure Connections Pairing supported but optional - 0x02: Secure Connections Pairing supported and mandatory (SC Only Mode) Values:<ul>
<li>0x00: SC_IS_NOT_SUPPORTED</li>
<li>0x01: SC_IS_SUPPORTED</li>
<li>0x02: SC_IS_MANDATORY </li>
</ul>
</td></tr>
    <tr><td class="paramname">KeyPress_Notification_Support</td><td>Keypress notification support Values:<ul>
<li>0x00: KEYPRESS_IS_NOT_SUPPORTED</li>
<li>0x01: KEYPRESS_IS_SUPPORTED </li>
</ul>
</td></tr>
    <tr><td class="paramname">Min_Encryption_Key_Size</td><td>Minimum encryption key size to be used during pairing </td></tr>
    <tr><td class="paramname">Max_Encryption_Key_Size</td><td>Maximum encryption key size to be used during pairing </td></tr>
    <tr><td class="paramname">Use_Fixed_Pin</td><td>Use or not fixed pin. If set to 0x00, then during the pairing process the application will not be requested for a pin (Fixed_Pin will be used). If set to 0x01, then during pairing process if a passkey is required the application will be notified Values:<ul>
<li>0x00: USE_FIXED_PIN_FOR_PAIRING</li>
<li>0x01: DONOT_USE_FIXED_PIN_FOR_PAIRING </li>
</ul>
</td></tr>
    <tr><td class="paramname">Fixed_Pin</td><td>Fixed pin to be used during pairing if MIMT protection is enabled. Any random value between 0 to 999999 Values:<ul>
<li>0 ... 999999 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Identity_Address_Type</td><td>Identity address type. Values:<ul>
<li>0x00: Public Identity Address</li>
<li>0x01: Random (static) Identity Address </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acafb71362ebef8fec2dc0c10a05c92e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_authorization_requirement </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Authorization_Enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the authorization requirements of the device. This command has to be given when connected to a device if authorization is required to access services which require authorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Authorization_Enable</td><td>Enable the authorization in the device and when a remote device tries to read/write a characteristic with authorization requirements, the stack will send back an error response with "Insufficient authorization" error code. After pairing is complete a ACI_GAP_AUTHORIZATION_REQ_EVENT will be sent to the Host. Values:<ul>
<li>0x00: AUTHORIZATION_NOT_REQUIRED</li>
<li>0x01: AUTHORIZATION_REQUIRED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a02945421ae32a96d2f2d90b99e6ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_broadcast_mode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Advertising_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Adv_Data_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Adv_Data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Num_of_Whitelist_Entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a>&#160;</td>
          <td class="paramname"><em>Whitelist_Entry</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command puts the device into broadcast mode. A privacy enabled device uses either a resolvable private address or a non-resolvable private address as specified in the Own_Addr_Type parameter of the command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Advertising_Interval_Min</td><td>Minimum advertising interval for undirected and low duty cycle directed advertising. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Interval_Max</td><td>Maximum advertising interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Type</td><td>Non connectable advertising type Values:<ul>
<li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li>
<li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>If Privacy is disabled, then the address can be public or static random. If Privacy is enabled, then the address can be a resolvable private address or a non-resolvable private address. Values:<ul>
<li>0x00: Public address</li>
<li>0x01: Static random address</li>
<li>0x02: Resolvable private address</li>
<li>0x03: Non-resolvable private address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Adv_Data_Length</td><td>Length of the advertising data in the advertising packet. </td></tr>
    <tr><td class="paramname">Adv_Data</td><td>Advertising data used by the device while advertising. </td></tr>
    <tr><td class="paramname">Num_of_Whitelist_Entries</td><td>Number of devices that have to be added to the whitelist. Values:<ul>
<li>0x00 ... 0xFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Whitelist_Entry</td><td>See <a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e333853ba4eb3b6e94f2acdf7597cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_direct_connectable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Directed_Advertising_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Direct_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Direct_Address</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the device in direct connectable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.3.3). Device uses direct connectable mode to advertise using High Duty cycle advertisement events or Low Duty cycle advertisement events and the address as either what is specified in the Own Address Type parameter. The command specifies the type of the advertising used. If the privacy is enabled, the Type parameter in reconnection address is used for advertising, otherwise the address of the type specified in OwnAddrType is used. The device will be in directed connectable mode only for 1.28 seconds. If no connection is established within this duration, the device enters non discoverable mode and advertising will have to be again enabled explicitly. The controller generates a hci_le_connection_complete_event event with the status set to 0x3C (Directed Advertising Timeout) if the connection was not established and 0x00 if the connection was successfully established. If Host privacy (i.e. privacy 1.1) is enabled this command returns BLE_STATUS_INVALID_PARAMS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (only if privacy is disabled) - 0x01: Random Device Address (only if privacy is disabled) - 0x02: Resolvable Private Address (only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Directed_Advertising_Type</td><td>Type of directed advertising. Values:<ul>
<li>0x01: High Duty Cycle Directed Advertising</li>
<li>0x04: Low Duty Cycle Directed Advertising </li>
</ul>
</td></tr>
    <tr><td class="paramname">Direct_Address_Type</td><td>Peer Address type. Values:<ul>
<li>0x00: Public Device Address or Public Identity Address</li>
<li>0x01: Random Device Address or Random (static) Identity Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Direct_Address</td><td>Initiator Bluetooth address </td></tr>
    <tr><td class="paramname">Advertising_Interval_Min</td><td>Minimum advertising interval for undirected and low duty cycle directed advertising. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Interval_Max</td><td>Maximum advertising interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b1795e7e98ac1e1165238b143a06dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_discoverable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Advertising_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Advertising_Filter_Policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Local_Name_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Local_Name</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Service_Uuid_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Service_Uuid_List</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Slave_Conn_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Slave_Conn_Interval_Max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device in general discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.4). The device will be discoverable until the host issues the <a class="el" href="bluenrg1__gap__aci_8h.html#aa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP uses the default values for adv intervals for general discoverable mode. When using connectable undirected advertising events: - Adv_Interval_Min = 30 ms - Adv_Interval_Max = 60 ms When using non- connectable advertising events or scannable undirected advertising events: - Adv_Interval_Min = 100 ms - Adv_Interval_Max = 150 ms Host can set the Local Name, a Service UUID list and the Slave Connection Interval Range. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be also set using <a class="el" href="bluenrg1__gap__aci_8h.html#aff0e0210b67c4fed57edc3e228365a8c" title="This command can be used to update the advertising data for a particular AD type. If the AD type spec...">aci_gap_update_adv_data()</a> separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - TX Power Level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Advertising_Type</td><td>Advertising type. Advertising_Type type cannot be any of GAP_ADV_HIGH_DC_DIRECT_IND or GAP_ADV_HIGH_DC_DIRECT_IND. Values:<ul>
<li>0x00: ADV_IND (Connectable undirected advertising)</li>
<li>0x01: ADV_DIRECT_IND (Connectable directed advertising)</li>
<li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li>
<li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Interval_Min</td><td>Minimum advertising interval for undirected and low duty cycle directed advertising. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Interval_Max</td><td>Maximum advertising interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Filter_Policy</td><td>Advertising filter policy: not applicable (the value of Advertising_Filter_Policy parameter is not used inside the Stack) </td></tr>
    <tr><td class="paramname">Local_Name_Length</td><td>Length of the local_name field in octets. If length is set to 0x00, Local_Name parameter is not used. </td></tr>
    <tr><td class="paramname">Local_Name</td><td>Local name of the device. First byte must be 0x08 for Shortened Local Name or 0x09 for Complete Local Name. No NULL character at the end. </td></tr>
    <tr><td class="paramname">Service_Uuid_length</td><td>Length of the Service Uuid List in octets. If there is no service to be advertised, set this field to 0x00. </td></tr>
    <tr><td class="paramname">Service_Uuid_List</td><td>This is the list of the UUIDs as defined in Volume 3, Section 11 of GAP Specification. First byte is the AD Type. See also Supplement to the Bluetooth Core specification. </td></tr>
    <tr><td class="paramname">Slave_Conn_Interval_Min</td><td>Minimum value for slave connection interval suggested by the Peripheral. If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000, Slave Connection Interval Range AD structure will be added in advertising data. Connection interval is defined in the following manner: connIntervalmin = Slave_Conn_Interval_Min x 1.25ms. Values:<ul>
<li>0x0000 (NaN)</li>
<li>0xFFFF (NaN) : No specific minimum</li>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Slave_Conn_Interval_Max</td><td>Slave connection interval maximum value suggested by Peripheral. If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000, Slave Connection Interval Range AD structure will be added in advertising data. Connection interval is defined in the following manner: connIntervalmax = Slave_Conn_Interval_Max x 1.25ms Values:<ul>
<li>0x0000 (NaN)</li>
<li>0xFFFF (NaN) : No specific maximum</li>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4d12352d4290eab988acdc90e3da93c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_event_mask </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>GAP_Evt_Mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It allows masking events from the GAP. The default configuration is all the events masked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GAP_Evt_Mask</td><td>GAP event mask. Default: 0xFFFF. Flags:<ul>
<li>0x0000: No events</li>
<li>0x0001: ACI_GAP_LIMITED_DISCOVERABLE_EVENT</li>
<li>0x0002: ACI_GAP_PAIRING_COMPLETE_EVENT</li>
<li>0x0004: ACI_GAP_PASS_KEY_REQ_EVENT</li>
<li>0x0008: ACI_GAP_AUTHORIZATION_REQ_EVENT</li>
<li>0x0010: ACI_GAP_SLAVE_SECURITY_INITIATED_EVENT</li>
<li>0x0020: ACI_GAP_BOND_LOST_EVENT</li>
<li>0x0080: ACI_GAP_PROC_COMPLETE_EVENT</li>
<li>0x0100: ACI_L2CAP_CONNECTION_UPDATE_REQ_EVENT</li>
<li>0x0200: ACI_L2CAP_CONNECTION_UPDATE_RESP_EVENT</li>
<li>0x0400: ACI_L2CAP_PROC_TIMEOUT_EVENT</li>
<li>0x0800: ACI_GAP_ADDR_NOT_RESOLVED_EVENT </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7e39b68644bdc0149ea9270427715cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_io_capability </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>IO_Capability</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the IO capabilities of the device. This command has to be given only when the device is not in a connected state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">IO_Capability</td><td>IO capability of the device. Values:<ul>
<li>0x00: IO_CAP_DISPLAY_ONLY</li>
<li>0x01: IO_CAP_DISPLAY_YES_NO</li>
<li>0x02: IO_CAP_KEYBOARD_ONLY</li>
<li>0x03: IO_CAP_NO_INPUT_NO_OUTPUT</li>
<li>0x04: IO_CAP_KEYBOARD_DISPLAY </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1472bbcc86d4f3b87615733a0c22bdd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_limited_discoverable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Advertising_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Advertising_Filter_Policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Local_Name_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Local_Name</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Service_Uuid_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Service_Uuid_List</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Slave_Conn_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Slave_Conn_Interval_Max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device in limited discoverable mode (as defined in Bluetooth Specification v.4.1, Vol. 3, Part C, section 9.2.3). The device will be discoverable for maximum period of TGAP (lim_adv_timeout) = 180 seconds (from errata). The advertising can be disabled at any time by issuing <a class="el" href="bluenrg1__gap__aci_8h.html#aa04d32f0009ee0df4fbe4643c4e593a5">aci_gap_set_non_discoverable</a> command. The Adv_Interval_Min and Adv_Interval_Max parameters are optional. If both are set to 0, the GAP will use default values for adv intervals for limited discoverable mode (250 ms and 500 ms respectively). To allow a fast connection, the host can set Local_Name, Service_Uuid_List, Slave_Conn_Interval_Min and Slave_Conn_Interval_Max. If provided, these data will be inserted into the advertising packet payload as AD data. These parameters are optional in this command. These values can be set in advertised data using GAP_Update_Adv_Data command separately. The total size of data in advertising packet cannot exceed 31 bytes. With this command, the BLE Stack will also add automatically the following standard AD types: - AD Flags - Power Level When advertising timeout happens (i.e. limited discovery period has elapsed), controller generates aci_gap_limited_discoverable_event event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Advertising_Type</td><td>Advertising type. Advertising_Type type cannot be any of GAP_ADV_HIGH_DC_DIRECT_IND or GAP_ADV_HIGH_DC_DIRECT_IND. Values:<ul>
<li>0x00: ADV_IND (Connectable undirected advertising)</li>
<li>0x01: ADV_DIRECT_IND (Connectable directed advertising)</li>
<li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li>
<li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Interval_Min</td><td>Minimum advertising interval for undirected and low duty cycle directed advertising. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Interval_Max</td><td>Maximum advertising interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Filter_Policy</td><td>Advertising filter policy: not applicable (the value of Advertising_Filter_Policy parameter is not used inside the Stack) </td></tr>
    <tr><td class="paramname">Local_Name_Length</td><td>Length of the local_name field in octets. If length is set to 0x00, Local_Name parameter is not used. </td></tr>
    <tr><td class="paramname">Local_Name</td><td>Local name of the device. First byte must be 0x08 for Shortened Local Name or 0x09 for Complete Local Name. No NULL character at the end. </td></tr>
    <tr><td class="paramname">Service_Uuid_length</td><td>Length of the Service Uuid List in octets. If there is no service to be advertised, set this field to 0x00. </td></tr>
    <tr><td class="paramname">Service_Uuid_List</td><td>This is the list of the UUIDs as defined in Volume 3, Section 11 of GAP Specification. First byte is the AD Type. See also Supplement to the Bluetooth Core specification. </td></tr>
    <tr><td class="paramname">Slave_Conn_Interval_Min</td><td>Minimum value for slave connection interval suggested by the Peripheral. If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000, Slave Connection Interval Range AD structure will be added in advertising data. Connection interval is defined in the following manner: connIntervalmin = Slave_Conn_Interval_Min x 1.25ms. Values:<ul>
<li>0x0000 (NaN)</li>
<li>0xFFFF (NaN) : No specific minimum</li>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Slave_Conn_Interval_Max</td><td>Slave connection interval maximum value suggested by Peripheral. If Slave_Conn_Interval_Min and Slave_Conn_Interval_Max are not 0x0000, Slave Connection Interval Range AD structure will be added in advertising data. Connection interval is defined in the following manner: connIntervalmax = Slave_Conn_Interval_Max x 1.25ms Values:<ul>
<li>0x0000 (NaN)</li>
<li>0xFFFF (NaN) : No specific maximum</li>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7581dbd49beb7d43c2c28a21bd352e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_non_connectable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Advertising_Event_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device into non connectable mode. This mode does not support connection. The privacy setting done in the <a class="el" href="bluenrg1__gap__aci_8h.html#afc8135485b2fce4116c825e226b43046">aci_gap_init</a> command plays a role in deciding the valid parameters for this command. Advertiser filter policy is internally set to 0x00. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Advertising_Event_Type</td><td>Advertising type. Values:<ul>
<li>0x02: ADV_SCAN_IND (Scannable undirected advertising)</li>
<li>0x03: ADV_NONCONN_IND (Non connectable undirected advertising) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa04d32f0009ee0df4fbe4643c4e593a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_non_discoverable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device in non-discoverable mode. This command disables the LL advertising. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0894787f7dd5af1e4f1a7ae1d3844f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_oob_data </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Device_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Address</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>OOB_Data_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>OOB_Data_Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>OOB_Data</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command is sent (by the User) to input the OOB data arrived via OOB communication. It may be sent to set either the OOB Authentication data of the Local device, or the data received via OOB by the Remote peer candidate device. It can be used with OOB_Data_Len set to 0 to generate OOB authentication data for Secure Connections. In a complete system (i.e. having an OOB channel fully handled) this command should be invoked by the OOB Channel manager when receiving the OOB data (hence without user interaction). Since the BLE stack v 2.x implementation supports just one entry for the Remote peer candidate list containing the OOB data, at every command invocation the data existing in that entry are overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Device_Type</td><td>OOB Device type: - 0x00: The Address information are ignored. - OOB_Data_Len= 0x00: this triggers the automatic regeneration of OOB Authentication data (for Secure Connections only; a ECDH-Public Key must). - OOB_Data_Len in [0..16]: the OOB_Data carried by the command will overwrite the current local Authentication OOB Data. - 0x01: The Address information is used to search the entry of the Remote peer candidate list containing the OOB data for that specific remote device; if no entry exists, the a new entry is used, if available (current implementation supports just 1 entry in this list). - OOB_Data_Len in [0..16]: the OOB_Data carried by the command overwrites (if present) the remote Authentication OOB Data. Values:<ul>
<li>0x00: Local device</li>
<li>0x01: Remote device </li>
</ul>
</td></tr>
    <tr><td class="paramname">Address_Type</td><td>Identity address type. Values:<ul>
<li>0x00: Public Identity Address</li>
<li>0x01: Random (static) Identity Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Address</td><td>Public or Random (static) address of the peer device </td></tr>
    <tr><td class="paramname">OOB_Data_Type</td><td>OOB Data type. - 0x00: Legacy Privacy (LP) v.4.1 TK (Temporary Key) - 0x01: Secure Connections (SC) v.4.2 Random value r used for generation of Confirm - 0x02: Secure Connections (SC) v.4.2 Confirm value C generated through AES-CMAC-128 based cryptographic function: C=f4(PKx, PKx, r, 0) Values:<ul>
<li>0x00: SM_TK</li>
<li>0x01: SM_RANDOM_VALUE</li>
<li>0x02: SM_CONFIRM_VALUE </li>
</ul>
</td></tr>
    <tr><td class="paramname">OOB_Data_Len</td><td>Length of OOB Data carried by next data field Values:<ul>
<li>0x00 ... 0x10 </li>
</ul>
</td></tr>
    <tr><td class="paramname">OOB_Data</td><td>OOB Data to be exported via OOB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2212b78100bc3c64553036247fa612bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_set_undirected_connectable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Advertising_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Adv_Filter_Policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the device into undirected connectable mode. If privacy is enabled in the device, a resolvable private address is generated and used as the advertiser's address. If not, the address of the type specified in own_addr_type is used for advertising. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Advertising_Interval_Min</td><td>Minimum advertising interval for undirected and low duty cycle directed advertising. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Advertising_Interval_Max</td><td>Maximum advertising interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0020 (20.000 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if controller privacy is enabled or if Host privacy (i.e. privacy 1.1) is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if Host privacy (i.e. privacy 1.1) is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Adv_Filter_Policy</td><td>Advertising filter policy. - 0x00: Allow Scan Request from Any, Allow Connect Request from Any - 0x03: Allow Scan Request from White List Only, Allow Connect Request from White List Only Values:<ul>
<li>0x00: NO_WHITE_LIST_USE</li>
<li>0x03: WHITE_LIST_FOR_ALL </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80162feee4f10fbfce5099ba0a7a61ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_slave_security_req </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a slave security request to the master. This command has to be issued to notify the master of the security requirements of the slave. The master may encrypt the link, initiate the pairing procedure, or reject the request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac95e16e25fa07dfc206eeafa1ab33c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_auto_connection_establish_proc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Latency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Supervision_Timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Minimum_CE_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Maximum_CE_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Num_of_Whitelist_Entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a>&#160;</td>
          <td class="paramname"><em>Whitelist_Entry</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the auto connection establishment procedure. The devices specified are added to the white list of the controller and a LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "use whitelist to determine which
       advertiser to connect to". When a command is issued to terminate the procedure by upper layer, a LE_Create_Connection_Cancel call will be made to the controller by GAP. The procedure is terminated when either a connection is successfully established with one of the specified devices in the white list or the procedure is explicitly terminated by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x08. A aci_gap_proc_complete_event event is returned with the procedure code set to 0x08. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Min</td><td>Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Max</td><td>Maximum value for the connection event interval. This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Supervision_Timeout</td><td>Supervision timeout for the LE Link. It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 msec. Values:<ul>
<li>0x000A (100 ms) ... 0x0C80 (32000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Minimum_CE_Length</td><td>Information parameter about the minimum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
    <tr><td class="paramname">Maximum_CE_Length</td><td>Information parameter about the maximum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
    <tr><td class="paramname">Num_of_Whitelist_Entries</td><td>Number of devices that have to be added to the whitelist. Values:<ul>
<li>0x00 ... 0xFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Whitelist_Entry</td><td>See <a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a261529d70c766ecd28e9b1464ffb9cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_connection_update </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Latency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Supervision_Timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Minimum_CE_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Maximum_CE_Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the connection update procedure (only when role is Master). A <a class="el" href="bluenrg1__hci__le_8h.html#a0b1c0e2aede814f82bab64c843710eb8">hci_le_connection_update</a> is called. On completion of the procedure, an hci_le_connection_update_complete_event event is returned to the upper layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Min</td><td>Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Max</td><td>Maximum value for the connection event interval. This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Supervision_Timeout</td><td>Supervision timeout for the LE Link. It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 msec. Values:<ul>
<li>0x000A (100 ms) ... 0x0C80 (32000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Minimum_CE_Length</td><td>Information parameter about the minimum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
    <tr><td class="paramname">Maximum_CE_Length</td><td>Information parameter about the maximum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51e87838aa189db795d10a3c4f8e7b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_general_connection_establish_proc </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Scanning_Filter_Policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Filter_Duplicates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a general connection establishment procedure. The host enables scanning in the controller with the scanner filter policy set to "accept all advertising packets" and from the scanning results, all the devices are sent to the upper layer using the event LE_Advertising_Report. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#ab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a>. If privacy is enabled, then either a private resolvable address or a non resolvable address, based on the address type specified in the command is set as the scanner address but the gap create connection always uses a private resolvable address if the general connection establishment procedure is active. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x10. On completion of the procedure a aci_gap_proc_complete_event event is generated with the procedure code set to 0x10. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Type</td><td>Passive or active scanning. With active scanning SCAN_REQ packets are sent. Values:<ul>
<li>0x00: Passive Scanning</li>
<li>0x01: Active scanning </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Scanning_Filter_Policy</td><td>Scanning filter policy: - 0x00 Accept all advertisement packets.Directed advertising packets which are not addressed for this device shall be ignored. - 0x01 Ignore advertisement packets from devices not in the White List Only.Directed advertising packets which are not addressed for this device shall be ignored. - 0x02 Accept all undirected advertisement packets (it is allowed only if controller privacy or host privacy is enabled).Directed advertisement packets where initiator address is a RPA and Directed advertisement packets addressed to this device shall be accepted. - 0x03 Accept all undirected advertisement packets from devices that are in the White List.Directed advertisement packets where initiator address is RPA and Directed advertisement packets addressed to this device shall be accepted. - NOTE: if controller privacy is enabled Scanning_Filter_Policy can only assume values 0x00 or 0x02; if Host privacy is enabled Scanning_Filter_Policy can only assume value 0x00. Values:<ul>
<li>0x00: Accept all</li>
<li>0x01: Ignore devices not in the White List</li>
<li>0x02: Accept all (use resolving list)</li>
<li>0x03: Ignore devices not in the White List (use resolving list) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Filter_Duplicates</td><td>Enable/disable duplicate filtering. Values:<ul>
<li>0x00: Duplicate filtering disabled</li>
<li>0x01: Duplicate filtering enabled </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaed8d0c8a1a23ca240dee0fb895d31df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_general_discovery_proc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Filter_Duplicates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the general discovery procedure. The controller is commanded to start active scanning. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x02 or a timeout happens. When the procedure is terminated due to any of the above reasons, aci_gap_proc_complete_event event is returned with the procedure code set to 0x02. The device found when the procedure is ongoing is returned to hci_le_advertising_report_event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Filter_Duplicates</td><td>Enable/disable duplicate filtering. Values:<ul>
<li>0x00: Duplicate filtering disabled</li>
<li>0x01: Duplicate filtering enabled </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96490c0e5a8d2f3c345b4992e477e403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_limited_discovery_proc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Filter_Duplicates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the limited discovery procedure. The controller is commanded to start active scanning. When this procedure is started, only the devices in limited discoverable mode are returned to the upper layers. The procedure is terminated when either the upper layers issue a command to terminate the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x01 or a timeout happens. When the procedure is terminated due to any of the above reasons, aci_gap_proc_complete_event event is returned with the procedure code set to 0x01. The device found when the procedure is ongoing is returned to the upper layers through the event hci_le_advertising_report_event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Filter_Duplicates</td><td>Enable/disable duplicate filtering. Values:<ul>
<li>0x00: Duplicate filtering disabled</li>
<li>0x01: Duplicate filtering enabled </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7035c09d3063ca239c4ada8172dc25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_name_discovery_proc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Peer_Address</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Interval_Max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Conn_Latency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Supervision_Timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Minimum_CE_Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Maximum_CE_Length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the name discovery procedure. A LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to "ignore whitelist and process connectable advertising packets only
       for the specified device". Once a connection is established, GATT procedure is started to read the device name characteristic. When the read is completed (successfully or unsuccessfully), a aci_gap_proc_complete_event event is given to the upper layer. The event also contains the name of the device if the device name was read successfully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address_Type</td><td>Address type. Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Peer_Address</td><td>Public Device Address, Random Device Address, Public Identity Address or Random (static) Identity Address of the advertising device. </td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Min</td><td>Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Interval_Max</td><td>Maximum value for the connection event interval. This shall be greater than or equal to Conn_Interval_Min. Time = N * 1.25 msec. Values:<ul>
<li>0x0006 (7.50 ms) ... 0x0C80 (4000.00 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Conn_Latency</td><td>Slave latency for the connection in number of connection events. Values:<ul>
<li>0x0000 ... 0x01F3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Supervision_Timeout</td><td>Supervision timeout for the LE Link. It shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2. Time = N * 10 msec. Values:<ul>
<li>0x000A (100 ms) ... 0x0C80 (32000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Minimum_CE_Length</td><td>Information parameter about the minimum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
    <tr><td class="paramname">Maximum_CE_Length</td><td>Information parameter about the maximum length of connection needed for this LE connection. Time = N * 0.625 msec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4943804581004fc2ce3e53a27b891918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_observation_proc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Filter_Duplicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Scanning_Filter_Policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an Observation procedure, when the device is in Observer Role. The host enables scanning in the controller. The advertising reports are sent to the upper layer using standard LE Advertising Report Event. (See Bluetooth Core v4.1, Vol. 2, part E, Ch. 7.7.65.2, LE Advertising Report Event). If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Type</td><td>Passive or active scanning. With active scanning SCAN_REQ packets are sent. Values:<ul>
<li>0x00: Passive Scanning</li>
<li>0x01: Active scanning </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Filter_Duplicates</td><td>Enable/disable duplicate filtering. Values:<ul>
<li>0x00: Duplicate filtering disabled</li>
<li>0x01: Duplicate filtering enabled </li>
</ul>
</td></tr>
    <tr><td class="paramname">Scanning_Filter_Policy</td><td>Scanning filter policy: - 0x00 Accept all advertisement packets (it is allowed only if controller privacy is enabled).Directed advertising packets which are not addressed for this device shall be ignored. - 0x01 Ignore advertisement packets from devices not in the White List Only.Directed advertising packets which are not addressed for this device shall be ignored. - 0x02 Accept all undirected advertisement packets (it is allowed only if controller privacy or host privacy is enabled).Directed advertisement packets where initiator address is a RPA and Directed advertisement packets addressed to this device shall be accepted. - 0x03 Accept all undirected advertisement packets from devices that are in the White List.Directed advertisement packets where initiator address is RPA and Directed advertisement packets addressed to this device shall be accepted. - NOTE: If Host privacy is enabled Scanning_Filter_Policy can only take values 0x00 or 0x01; Values:<ul>
<li>0x00: Accept all</li>
<li>0x01: Ignore devices not in the White List</li>
<li>0x02: Accept all (use resolving list)</li>
<li>0x03: Ignore devices not in the White List (use resolving list) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6a383c19db7453b5d50e729b01fe6bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_start_selective_connection_establish_proc </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>LE_Scan_Window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Own_Address_Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Scanning_Filter_Policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Filter_Duplicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Num_of_Whitelist_Entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a>&#160;</td>
          <td class="paramname"><em>Whitelist_Entry</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a selective connection establishment procedure. The GAP adds the specified device addresses into white list and enables scanning in the controller with the scanner filter policy set to "accept packets only
       from devices in whitelist". All the devices found are sent to the upper layer by the event hci_le_advertising_report_event. The upper layer then has to select one of the devices to which it wants to connect by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#ab5d8d5792788d6cc511c36e1eddabf3d">aci_gap_create_connection</a>. On completion of the procedure a aci_gap_proc_complete_event event is generated with the procedure code set to 0x20. The procedure is terminated when a connection is established or the upper layer terminates the procedure by issuing the command <a class="el" href="bluenrg1__gap__aci_8h.html#a39804c69a0cdbd3579b0d3be400665b1">aci_gap_terminate_gap_proc</a> with the procedure code set to 0x20. If controller privacy is enabled and the peer device (advertiser) is in the resolving list then the link layer will generate a RPA, if it is not then the RPA/NRPA generated by the Host will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LE_Scan_Type</td><td>Passive or active scanning. With active scanning SCAN_REQ packets are sent. Values:<ul>
<li>0x00: Passive Scanning</li>
<li>0x01: Active scanning </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Interval</td><td>This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">LE_Scan_Window</td><td>The duration of the LE scan. LE_Scan_Window shall be less than or equal to LE_Scan_Interval. Time = N * 0.625 msec. Values:<ul>
<li>0x0004 (2.500 ms) ... 0x4000 (10240.000 ms) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Own_Address_Type</td><td>Own address type: - 0x00: Public Device Address (it is allowed only if privacy is disabled) - 0x01: Random Device Address (it is allowed only if privacy is disabled) - 0x02: Resolvable Private Address (it is allowed only if privacy is enabled) - 0x03: Non Resolvable Private Address (it is allowed only if privacy is enabled) Values:<ul>
<li>0x00: Public Device Address</li>
<li>0x01: Random Device Address</li>
<li>0x02: Resolvable Private Address</li>
<li>0x03: Non Resolvable Private Address </li>
</ul>
</td></tr>
    <tr><td class="paramname">Scanning_Filter_Policy</td><td>Scanning filter policy: - 0x00 Accept all advertisement packets.Directed advertising packets which are not addressed for this device shall be ignored. - 0x01 Ignore advertisement packets from devices not in the White List Only.Directed advertising packets which are not addressed for this device shall be ignored. - 0x02 Accept all undirected advertisement packets (it is allowed only if controller privacy or host privacy is enabled).Directed advertisement packets where initiator address is a RPA and Directed advertisement packets addressed to this device shall be accepted. - 0x03 Accept all undirected advertisement packets from devices that are in the White List.Directed advertisement packets where initiator address is RPA and Directed advertisement packets addressed to this device shall be accepted. - NOTE: if controller privacy is enabled Scanning_Filter_Policy can only assume values 0x01 or 0x03; if Host privacy is enabled Scanning_Filter_Policy can only assume value 0x01. Values:<ul>
<li>0x00: Accept all</li>
<li>0x01: Ignore devices not in the White List</li>
<li>0x02: Accept all (use resolving list)</li>
<li>0x03: Ignore devices not in the White List (use resolving list) </li>
</ul>
</td></tr>
    <tr><td class="paramname">Filter_Duplicates</td><td>Enable/disable duplicate filtering. Values:<ul>
<li>0x00: Duplicate filtering disabled</li>
<li>0x01: Duplicate filtering enabled </li>
</ul>
</td></tr>
    <tr><td class="paramname">Num_of_Whitelist_Entries</td><td>Number of devices that have to be added to the whitelist. Values:<ul>
<li>0x00 ... 0xFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Whitelist_Entry</td><td>See <a class="el" href="bluenrg1__gap__aci_8h.html#a5ad574baee6641a0326ee817f2d278b4">Whitelist_Entry_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c1b1aca7489a846f3aaa25cdb9db180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_terminate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Connection_Handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Command the controller to terminate the connection. A hci_disconnection_complete_event event will be generated when the link is disconnected. It is important to leave an 100 ms blank window before sending any new command (including system hardware reset), since immediately after hci_disconnection_complete_event event, system could save important information in non volatile memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Connection_Handle</td><td>Connection handle that identifies the connection. Values:<ul>
<li>0x0000 ... 0x0EFF </li>
</ul>
</td></tr>
    <tr><td class="paramname">Reason</td><td>The reason for ending the connection. Values:<ul>
<li>0x05: Authentication Failure</li>
<li>0x13: Remote User Terminated Connection</li>
<li>0x14: Remote Device Terminated Connection due to Low Resources</li>
<li>0x15: Remote Device Terminated Connection due to Power Off</li>
<li>0x1A: Unsupported Remote Feature</li>
<li>0x3B: Unacceptable Connection Parameters </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39804c69a0cdbd3579b0d3be400665b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_terminate_gap_proc </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>Procedure_Code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate the specified GATT procedure. An aci_gap_proc_complete_event event is returned with the procedure code set to the corresponding procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Procedure_Code</td><td>GAP procedure bitmap. Values:<ul>
<li>0x00: No events</li>
<li>0x01: LIMITED_DISCOVERY_PROC</li>
<li>0x02: GENERAL_DISCOVERY_PROC</li>
<li>0x04: NAME_DISCOVERY_PROC</li>
<li>0x08: AUTO_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x10: GENERAL_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x20: SELECTIVE_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x40: DIRECT_CONNECTION_ESTABLISHMENT_PROC</li>
<li>0x80: OBSERVATION_PROC </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff0e0210b67c4fed57edc3e228365a8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBleStatus aci_gap_update_adv_data </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>AdvDataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>AdvData</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command can be used to update the advertising data for a particular AD type. If the AD type specified does not exist, then it is added to the advertising data. If the overall advertising data length is more than 31 octets after the update, then the command is rejected and the old data is retained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AdvDataLen</td><td>Length of AdvData in octets </td></tr>
    <tr><td class="paramname">AdvData</td><td>Advertising data used by the device while advertising. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>indicating success or error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2020 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
